<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="GeekOUC">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="GeekOUC">
<meta property="article:author" content="田济荣">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>GeekOUC</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?345da8a17ad1f3825bc080f35df3590b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GeekOUC</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-简历">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            简历
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/" itemprop="url">多线程与并发编程学习笔记02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-24T09:04:00+08:00">
                2020-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tags-多线程"><a href="#tags-多线程" class="headerlink" title="tags:多线程"></a>tags:多线程</h2><h2 id="多线程与并发编程学习笔记02"><a href="#多线程与并发编程学习笔记02" class="headerlink" title="多线程与并发编程学习笔记02"></a>多线程与并发编程学习笔记02</h2><h3 id="13-阻塞队列-（多线程并发和线程池的时候经常使用）"><a href="#13-阻塞队列-（多线程并发和线程池的时候经常使用）" class="headerlink" title="13. 阻塞队列  （多线程并发和线程池的时候经常使用）"></a>13. 阻塞队列  （多线程并发和线程池的时候经常使用）</h3><p>BlockQueue接口：<strong>指定队列大小</strong>,若队列满则阻塞等待；取元素时若为空则阻塞等待</p>
<p>Queue接口的类图</p>
<p><img src="https://i.loli.net/2020/08/24/o12Yl6mwFZOHikx.png" alt="image-20200824092340874"></p>
<p><strong>重要的实现类：</strong></p>
<p>-&gt; <strong>ArrayBlockingQueue</strong> </p>
<p>-&gt; <strong>LinkedBlockingQueue</strong></p>
<p>-&gt; <strong>SynchronousQueue【重点】</strong></p>
<p><strong>4组API：</strong></p>
<table>
<thead>
<tr>
<th>方法/API</th>
<th>抛出异常</th>
<th>返回值</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素</td>
<td><strong>add()</strong></td>
<td><strong>offer()</strong></td>
<td><strong>put()</strong></td>
<td><strong>offer(”a”,2,秒)</strong></td>
</tr>
<tr>
<td>移除元素</td>
<td><strong>remove()</strong></td>
<td><strong>poll()</strong></td>
<td><strong>take()</strong></td>
<td><strong>poll(2,秒)</strong></td>
</tr>
<tr>
<td>查看队列首</td>
<td><strong>element()</strong></td>
<td><strong>peek()</strong></td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>SynchronousQueue 同步队列：</strong>【进一个取一个】</p>
<p><strong>SynchronousQueue没有容量，是无缓冲等待队列</strong>，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</p>
<p>拥有<strong>公平(FIFO)(TransferQueue)和非公平(LIFO)(TransferStack)策略</strong>，非公平策略会导致一些数据永远无法被消费的情况.</p>
</li>
</ul>
<h3 id="14-线程池【重要】【3大方法-7大参数-4种拒绝】"><a href="#14-线程池【重要】【3大方法-7大参数-4种拒绝】" class="headerlink" title="14.线程池【重要】【3大方法/7大参数/4种拒绝】"></a>14.线程池【重要】【3大方法/7大参数/4种拒绝】</h3><p><strong>14.1 池化技术</strong>：线程池、数据库连接池、内存池、常量池…</p>
<p><strong>线程池</strong>： 线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，<strong>线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务</strong>，执行结束以后，该线程并不会死亡，而是<strong>再次返回线程池中成为空闲状态，等待执行下一个任务</strong>。</p>
<ul>
<li>工作机制：<ul>
<li>在线程池的编程模式下，任务提交给整个线程池，而不是直接提交给某个线程，<strong>线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程</strong>。</li>
<li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</li>
</ul>
</li>
<li>优点：<ul>
<li>避免线程的频繁创建、销毁；提高<strong>效率和访问速度</strong>。</li>
<li>实现<strong>线程复用</strong>、<strong>线程管理</strong>、控制<strong>最大并发</strong>数。</li>
</ul>
</li>
</ul>
<p><strong>14.2 创建线程池</strong>的方法：</p>
<ol>
<li>使用<strong>Executors工具类</strong>的3种构造方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newsingleThreadExecutor();  <span class="comment">//单个线程的线程池</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPoo1 = Executors.newFixedThreadpool(<span class="number">5</span>); </span><br><span class="line"><span class="comment">//创建一个固定的线程池的大小</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool(); </span><br><span class="line"><span class="comment">//可伸缩的，遇强则强，遇弱则弱</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<strong>ThreadPoolExecutor构造方法</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程池基本大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSzie,//最大线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//非核心线程的超时时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//超时的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工厂：用于创建线程</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler//拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">                         )</span></span></span><br></pre></td></tr></table></figure>

<p>两种方法本质：都是调用了<strong>ThreadPoolExecutor (7个参数)</strong>【因此：<strong>线程池要使用此方法去创建</strong>，而不是用Executors下的方法】</p>
<p><strong>14.3 线程池调用流程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用构造方法后，返回一个线程池threadPool;</span><br><span class="line">threadPool.execute();<span class="comment">//使用线程池提交任务：</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/08/24/fxcMDjmCkoZVbnQ.png" alt="image-20200824130100218"></p>
<ol>
<li>如果当前线程池中的线程数目<strong>小于corePoolSize</strong>，则每来一个任务，就会<strong>创建一个线程</strong>去执行这个任务；</li>
<li>如果当前线程池中的线程数目<strong>&gt;=corePoolSize</strong>，则每来一个任务，会尝试将<strong>该任务添加到任务缓存队列</strong>中，若添加成功，则该任务会<strong>等待空闲线程将其取出去执行</strong>；若<strong>添加失败</strong>（一般来说是任务缓存队列已满），则会尝试<strong>创建新的线程</strong>去执行这个任务；</li>
<li>如果当前线程池中的<strong>线程数达到maximumPoolSize</strong>，则会采取任务<strong>拒绝策略</strong>进行处理；</li>
<li>如果线程池中的线程数量<strong>大于 corePoolSize时</strong>，如果某线程空闲时间<strong>超过keepAliveTime，线程将被终止</strong>，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
</ol>
<p><strong>14.4 为什么使用阻塞队列</strong>？</p>
<p><strong>阻塞队列主要是用于生产者-消费者模型的情况</strong>： 比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒(不需要我们编写代码去唤醒)。</p>
<p>​        这样提供了极大的方便性。 如果使用非阻塞队列，它不会对当前线程产生阻塞,就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。</p>
<p><strong>拒绝策略</strong>：4种：</p>
<table>
<thead>
<tr>
<th>ThreadPoolExecutor.AbortPolicy</th>
<th>丢弃任务，并抛出RejectedExecutionException异常【默认】</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ThreadPoolExecutor.AbortPolicy</strong></td>
<td>丢弃任务，但是<strong>不抛出</strong>异常</td>
</tr>
<tr>
<td><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong></td>
<td><strong>丢弃队列最老的</strong>任务，然后重新提交被拒绝的任务</td>
</tr>
<tr>
<td><strong>ThreadPoolExecutor.CallerRunsPolicy</strong></td>
<td>由<strong>调用线程（提交任务的线程）处理</strong>该任务</td>
</tr>
</tbody></table>
<p><strong>14.5 最大线程数如何选择？</strong></p>
<p>CPU密集型任务：maximumPoolSize = CPU核心数量；保持CPU效率最高</p>
<p>IO 密集型任务 ：maximumPoolSize = CPU核心数量 * 2；</p>
<h3 id="15-函数式接口【重要】："><a href="#15-函数式接口【重要】：" class="headerlink" title="15. 函数式接口【重要】："></a>15. 函数式接口【重要】：</h3><p>新时代的程序员要掌握的编程技术: lambda表达式、链式编程、 函数式接口、Stream流式计算</p>
<p><code>函数式接口：只有一个方法的接口  @FunctionalInterface</code></p>
<p><strong>15.1 4种函数式接口:</strong></p>
<ul>
<li><p><strong>Function</strong>【<strong>函数型</strong>】：一个输入，输出一个返回值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, String&gt; function = str -&gt; &#123;<span class="keyword">return</span> str;&#125;; <span class="comment">//lambda表达式简化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Predicate【判断型】:</strong> 一个输入，输出一个boolean的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = String::isEmpty;<span class="comment">//判断字符串是否为空的函数</span></span><br><span class="line">        System.out.println(predicate.test(<span class="string">"111"</span>));<span class="comment">//输出false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Consumer【消费型</strong>】：一个输入，没返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = System.out::println;<span class="comment">//只是打印，没有返回值</span></span><br><span class="line">        consumer.accept(<span class="string">"12345"</span>);<span class="comment">//打印了”12345“</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Supplier 【供给型】</strong>：没有输入，只有返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Integer&gt; supplier = () -&gt; <span class="number">1024</span>;<span class="comment">//没有参数</span></span><br><span class="line">    System.out.println(supplier.get());<span class="comment">//提供1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>15.2 Stream 流式计算：</strong></p>
<img src="https://i.loli.net/2020/08/24/RmMiufY5bTerFJH.png" alt="image-20200824150553674 " style="zoom:70%;" />



<h3 id="16-ForkJoin"><a href="#16-ForkJoin" class="headerlink" title="16. ForkJoin"></a>16. ForkJoin</h3><p>Since : JDK1.7+</p>
<p>原理：</p>
<ol>
<li><strong>分治</strong></li>
</ol>
<img src="https://i.loli.net/2020/08/24/QrhpPVwEMlvR3BN.png" alt="image-20200824152323862" style="zoom:67%;" />

<ol start="2">
<li><strong>工作窃取</strong>：工作窃取算法是指某个线程从其他队列里窃取任务来执行。</li>
</ol>
<img src="https://i.loli.net/2020/08/25/79Nt4ghOSbJWfHM.png" alt="image-20200825132323848" style="zoom:50%;" />

<p>​    - 工作窃取算法的优点：<strong>充分利用线程</strong>进行<strong>并行</strong>计算，减少了线程间的竞争。</p>
<pre><code>- 工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如**创建多个线程和多个双端队列**。</code></pre><p>ForkJoin类似于分治思想，只是分成小任务后使用的是多个线程并行执行小任务，从而加速计算。</p>
<p><strong>但是还是Stream并行流式计算，速度最快</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10</span>_ <span class="number">0000</span>_ _00L).parallel().reduce( identity:<span class="number">0</span>,Long::sum);</span><br></pre></td></tr></table></figure>

<p>只需1行代码，运算速度快100倍！</p>
<h3 id="17-异步回调"><a href="#17-异步回调" class="headerlink" title="17. 异步回调"></a>17. 异步回调</h3><ul>
<li><p><strong>是什么</strong>？在发起一个异步任务的同时指定一个函数，在<strong>异步任务完成时会自动的调用这个函数</strong>。</p>
</li>
<li><p><strong>为什么</strong>？需要<strong>获取异步任务的执行结果</strong>，但是<strong>又不应该让其阻塞</strong>（降低效率），即想要高效的获取任务的执行结果。</p>
</li>
<li><p><strong>怎么实现？</strong>使用Future接口下的<strong>CompletableFuture</strong>类；它的方法有：<strong>runAsync()</strong>;(无返回值)  <strong>supplyAsync()</strong>;有返回值；</p>
</li>
</ul>
<h3 id="18-JMM"><a href="#18-JMM" class="headerlink" title="18. JMM"></a>18. JMM</h3><ul>
<li><p><strong>JMM带来的问题</strong>:</p>
<p>1) <strong>可见性问题</strong>：</p>
<p>​        CPU中运行的线程从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个<strong>变更对运行在右边CPU中的线程不可见</strong>，因为这个<strong>更改还没有flush到主存中</strong>。</p>
<p>​        要解决共享对象可见性这个问题，我们可以使用 <strong>volatile</strong>关键字或者是<strong>加锁</strong>：</p>
<img src="https://i.loli.net/2020/08/25/r5Bw8gemhjHISYU.png" alt="image-20200825145545276 " style="zoom:50%;" />



</li>
</ul>
<p>​    2）<strong>竞争问题</strong>：</p>
<p>​        线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中<strong>。如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3</strong>。然而下图中两个加1操作是<strong>并行的</strong>，不管是线程A还是线程B先flush计算结果到主存，<strong>最终主存中的Obj.count只会增加1次变成2</strong>，尽管一共有两次加1操作。 要解决上面的问题我们可以使用 <strong>synchronized</strong>代码块。</p>
<ul>
<li><p>JMM<strong>中的指令重排：</strong></p>
<ul>
<li><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，指令重排包括：</p>
<ul>
<li><strong>编译器</strong>优化</li>
<li><strong>CPU</strong>的指令级并行</li>
<li><strong>内存</strong>系统重排序</li>
</ul>
</li>
<li><p><strong>as-if-serial关系 ：</strong> 不管怎么重排序（编译器和处理器为了提高并行度,程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>，因为这种重排序会改变执行结果。【仅限于<strong>单线程</strong>】</p>
<p><strong>多线程下JMM的指令重排带来的问题</strong>：在多线程中：对存在控制依赖的操作重排序，可能会改变程序的执行结果.</p>
</li>
<li><p><strong>happens-before关系</strong>：保证正确同步的多线程程序的执行结果不被改变，满足可见性的程序都满足此关系。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>volitale</strong>关键字可解决：</p>
<ul>
<li><p><strong>可见性</strong>：【原理是<strong>MESI</strong>】</p>
<ul>
<li>当<strong>写</strong>一个volatile变量时：JMM会把该线程对应的本地内存中的共享变量值<strong>立即刷新到主内存</strong>。</li>
<li>当<strong>读</strong>一个volatile变量时：JMM会把该线程对应的<strong>本地内存变量置为无效</strong>。线程接下来将<strong>从主内存中读取</strong>共享变量。</li>
</ul>
</li>
<li><p><strong>有序性</strong>：【原理是<strong>内存屏障</strong>】：</p>
<ul>
<li><strong>volatile写操作</strong>的前面插入一个<strong>StoreStore屏障</strong>，后面插入一个<strong>StoreLoad屏障</strong>，禁止前面指令和后面指令交换顺序。</li>
<li><strong>volatile读操作</strong>的后面插入一个<strong>LoadLoad屏障</strong>， 后面插入一个<strong>LoadStore屏障</strong>，禁止前面指令和后面指令交换顺序。</li>
</ul>
</li>
<li><p><strong>不保证原子性：</strong></p>
<p>对任意单个volatile变量的读/写具有原子性，但类似于<strong>i++这种复合操作不具有原子性</strong>。</p>
<p><strong>那么如何保证原子性呢</strong>？ -&gt; lock、synchronized 【效率低】</p>
<p>​                                            -&gt; <strong>使用原子类</strong>，例如AtomicInteger等；【底层是CAS】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">num.getAndIncrement(); <span class="comment">// AtomicInteger + 1 ; 此方法原理是使用了 CAS</span></span><br></pre></td></tr></table></figure>

<p>原子类的底层都直接和操作系统挂钩! 在内存中修改值! 其使用到的Unsafe类是一个很特殊的存在 !</p>
</li>
</ul>
</li>
</ul>
<h3 id="19-单例模式"><a href="#19-单例模式" class="headerlink" title="19. 单例模式"></a>19. 单例模式</h3><p> <strong>1. 饿汉式</strong>:【永远提前加载，耗费系统资源】</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>饿汉式</strong>：【双重检测+锁+Volatile】<strong>重要</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonLazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonLazy<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazy = <span class="keyword">new</span> SingletonLazy(); <span class="comment">//这不是一个原子性操作!</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>为何要双重检测</strong>？因为除第一次调用外，大部分情况是单例已经创建，因此在外层加锁会导致每次调用此方法都会加锁，影响性能。所以在内层加锁，并且进入内层之后需要再次进行判断单例是否已经存在，若仍不存在，此时才可放心创建。</p>
</li>
<li><p><strong>为何声明单例时要加volatile？</strong>因为<code>lazy = new SingletonLazy();</code><strong>不是一个原子性操作,</strong>其步骤是：</p>
<ol>
<li>分配内存空间</li>
<li>执行构造方法 初始化对象</li>
<li>把对象指向这个内存空间</li>
</ol>
<p>由于<strong>指令重排</strong>的存在，可能使上述指令变为1-&gt;3-&gt;2的顺序，这样就会<strong>导致其他线程获取一个null的单例对象</strong>；</p>
</li>
</ul>
<ol start="3">
<li><p><strong>静态内部类实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Holder HOLDER = <span class="keyword">new</span> Holder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><strong>安全问题</strong>：无论是使用以上哪种方式，只要是以<strong>private修饰构造器</strong>用来限制外部调用的，都可以用<strong>反射机制破解</strong>！</p>
<ul>
<li><p>首先用<strong>getDeclaredConstructor()</strong>通过反射获取构造器</p>
</li>
<li><p>然后用<strong>setAccessible(true)</strong>即可无视构造器的private修饰符</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SingletonLazy instance1 = SingletonLazy.getLazy();</span><br><span class="line">        Constructor&lt;SingletonLazy&gt; constructor = SingletonLazy<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;<span class="comment">//通过反射获取构造器</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);<span class="comment">//通过反射 无视构造器的private修饰符！！</span></span><br><span class="line">        SingletonLazy instance2 = constructor.newInstance();</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>那么，单例类如何防止反射？</strong></p>
<p>在其构造器内加入<strong>flag秘钥校验</strong>，使其在第二次被调用时抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="keyword">false</span>)&#123;  </span><br><span class="line">            flag = !flag;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例模式被侵犯！"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，若<strong>flag秘钥被泄露</strong>，同样可以通过<strong>反射</strong>将flag设置为相应的值，从而破解单例模式。</p>
<ol start="5">
<li>使用 <strong>枚举类enum</strong> 【现如今最推荐的单例模式方法】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum默认就是单例的,又简单又牛逼,不存在安全问题！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>修复安全问题：</strong></p>
<ul>
<li><p>当我们尝试像往常一样使反射破解枚举类时：</p>
<p>出现异常:<strong>Cannot reflectively create enum objects</strong>【不能通过反射创建枚举对象】</p>
<p>这是因为反射包的newInstance()方法中添加了以上的异常，<strong>禁止了通过反射创建枚举对象</strong>。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        EnumSingle instance1 = EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; constructor = EnumSingle<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//注意：枚举类只有有参构造器！</span></span><br><span class="line">        <span class="comment">//尝试使反射破解枚举类时,出现异常:Cannot reflectively create enum objects！</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        EnumSingle instance2 = constructor.newInstance();</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>序列化问题</strong></p>
<p>当使用反序列化时，也会破坏单例模式，导致<strong>反序列化时生成的实例和之前的实例并不是同一个</strong>！</p>
<p>而由于枚举类enum优先于反序列化方法readResolve(),因此<strong>不会被反序列化破坏单例</strong>。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/21/JVM%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/JVM%E8%B0%83%E4%BC%98/" itemprop="url">JVM调优</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T00:52:26+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tags-JVM"><a href="#tags-JVM" class="headerlink" title="tags:JVM"></a>tags:JVM</h2><p>JVM调优</p>
<ol>
<li><h4 id="如何避免频繁fullGC"><a href="#如何避免频繁fullGC" class="headerlink" title="如何避免频繁fullGC?"></a>如何避免频繁fullGC?</h4></li>
</ol>
<ul>
<li><p>出现fullgc的原因：</p>
<p>1.年轻代空间不足</p>
<p>2.per Gen（永久代）空间满</p>
<p>3.CMS GC时出现promotion failed和concurrent mode failure</p>
<p>4.统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间等</p>
</li>
<li><p>解决：</p>
<ul>
<li>增大survive区大小</li>
<li>降低大对象的生命周期</li>
<li>避免产生过多可以避免的大对象</li>
<li><strong>增大永久代空间</strong></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">多线程与并发编程学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-17T16:24:12+08:00">
                2020-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tags-多线程"><a href="#tags-多线程" class="headerlink" title="tags:多线程"></a>tags:多线程</h2><h2 id="多线程与并发编程学习笔记01"><a href="#多线程与并发编程学习笔记01" class="headerlink" title="多线程与并发编程学习笔记01"></a>多线程与并发编程学习笔记01</h2><p><strong>1. 什么是JUC</strong>：java.util.concurrent 并发工具包；</p>
<p><strong>2. 线程与进程</strong>：</p>
<p><strong>进程</strong>：一段代码程序执行的过程；一个进程可包含多个线程；</p>
<p>​        在 Java 本身启动时会创建若干个线程，除了 main 线程之外，还有Monitor Ctrl-Break，Signal Dispatcher，Finalizer，Reference Handler。</p>
<p><strong>线程</strong>：</p>
<p>​        Java真的能开启多个线程吗？否。是使用的<strong>native方法start0()开启的线程</strong>。因为JAVA运行在虚拟机上，无法直接操作硬件。</p>
<p><strong>线程6大状态</strong>：（可在Thread类的源码中找到）</p>
<p>NEW -&gt; RUNNABLE -&gt; BLOCKED -&gt;WAITING -&gt; TIME_WAITING -&gt; TERMINATED</p>
<p><strong>3. 并发与并行</strong>：</p>
<p><strong>并发</strong>：多线程操作同一个资源；多线程是模拟出来的，是<strong>CPU时间片轮转快速交替执行</strong>而已。并发编程是为了:充分利用CPU性能资源.</p>
<p><strong>并行</strong>：CPU<strong>多个物理核心</strong>,多个线程可以同时执行;可<strong>使用线程池</strong>：</p>
<p><strong>线程池的数量</strong>：</p>
<p><strong>IO密集型</strong>=2Ncpu（可以测试后自己控制大小，2Ncpu一般没问题）（常出现于线程中：数据库数据交互、文件上传下载、网络数据传输等等）</p>
<p><strong>计算密集型</strong>=Ncpu（常出现于线程中：复杂算法）</p>
<p><strong>4. wait/sleep的区别：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>wait</th>
<th>sleep</th>
</tr>
</thead>
<tbody><tr>
<td><strong>所属的类</strong></td>
<td>Object</td>
<td>Thread</td>
</tr>
<tr>
<td><strong>是否释放锁</strong></td>
<td>释放了锁</td>
<td>不会释放锁</td>
</tr>
<tr>
<td><strong>使用范围</strong></td>
<td>必须在同步代码块中使用</td>
<td>可以在任何地方进入sleep</td>
</tr>
<tr>
<td><strong>是否捕获异常</strong></td>
<td>不需要捕获</td>
<td>必须捕获异常</td>
</tr>
</tbody></table>
<p><strong>5. 什么是锁，锁的是谁：</strong></p>
<p><strong>8锁问题</strong>：</p>
<ul>
<li><p><strong>场景1：两个 synchronized 实例方法：按拿锁顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标准情况下 是先sendEmail()还是先callPhone()?</span></span><br><span class="line"><span class="comment"> * 答案：sendEmail</span></span><br><span class="line"><span class="comment"> * 解释：被 synchronized 修饰的方式，锁的对象是方法的调用者（phone1）</span></span><br><span class="line"><span class="comment"> * 所以说这里两个方法想要获取的是同一个锁，谁先拿到锁谁先执行！这里是顺序拿锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone1 phone1 = <span class="keyword">new</span> Phone1();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendEmail();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.callPhone();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"senEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景2：两个 synchronized 实例方法，并在其中一种方法中添加sleep休眠：依然按拿锁顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sendEmail()方法执行时会休眠三秒。  是先执行sendEmail() 还是 callPhone()？</span></span><br><span class="line"><span class="comment"> * 答案： sendEmail</span></span><br><span class="line"><span class="comment"> * 解释：被 synchronized 修饰的方式，锁的对象是方法的调用者（phone2）</span></span><br><span class="line"><span class="comment"> * 所以说这里两个方法想要获取的是同一个锁，谁先拿到锁谁先执行！（也就是说，和方法本身执行的耗时无关）顺序拿锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone2 phone2 = <span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.callPhone();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//该方法会睡3秒</span></span><br><span class="line">        System.out.println(<span class="string">"sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景3：一个synchronized实例方法，一个普通实例方法：按时间顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被synchronized 修饰的方法和普通方法 先执行加锁方法sendEmail() 还是 普通方法callPhone()？</span></span><br><span class="line"><span class="comment"> * 答案： callPhone</span></span><br><span class="line"><span class="comment"> * 解释：新增加的这个方法没有 synchronized 修饰，不是同步方法，不受锁的影响，所以按时间顺序执行；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone3 phone3 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone3.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone3.callPhone();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有synchronized修饰的普通方法：先于加锁方法执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景4：两个 synchronized 实例方法对应两个调用者实例：按时间顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被synchronized 修饰的不同方法 先执行sendEmail() 还是callPhone()？</span></span><br><span class="line"><span class="comment"> * 答案：callPhone</span></span><br><span class="line"><span class="comment"> * 解释：被synchronized 修饰的不同方法 锁的对象是调用者</span></span><br><span class="line"><span class="comment"> * 这里锁的是两个不同的调用者，所有互不影响，按时间顺序执行；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone4 phoneA = <span class="keyword">new</span> Phone4();</span><br><span class="line">        Phone4 phoneB = <span class="keyword">new</span> Phone4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phoneA.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phoneB.callPhone();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//睡3秒</span></span><br><span class="line">        System.out.println(<span class="string">"sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景5：两个 static synchronized 静态方法：按拿锁顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个静态同步方法 都被synchronized 修饰 是先sendEmail() 还是callPhone()？</span></span><br><span class="line"><span class="comment"> * 答案：sendEmial</span></span><br><span class="line"><span class="comment"> * 解释：只要方法被 static 修饰，锁的对象就是 Class模板对象,这个则全局唯一！</span></span><br><span class="line"><span class="comment"> *      这里是同一个锁，先获取到锁的先执行；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone5 phone5 = <span class="keyword">new</span> Phone5();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone5.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone5.callPhone();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景6：两个 static synchronized 静态方法，使用两个实例调用：按拿锁顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同被static+synchronized 修饰的两个方法，是先sendEmail()还是callPhone()?</span></span><br><span class="line"><span class="comment"> *  答案：sendEmail</span></span><br><span class="line"><span class="comment"> *  解释：虽然有两个对象，但锁的对象是 Class模板,这个全局唯一,所以按方法获取到Class模板锁的顺序执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone5 phone5 = <span class="keyword">new</span> Phone5();</span><br><span class="line">        Phone5 phone5s = <span class="keyword">new</span> Phone5();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone5.sendEmail();</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone5s.callPhone();</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//sleep三秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景7：一个 synchronized 实例方法和一个 static synchronized 静态方法：按时间顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被synchronized 修饰的普通方法和静态方法  是先sendEmail() 还是 callPhone()?</span></span><br><span class="line"><span class="comment"> * 答案：callPhone</span></span><br><span class="line"><span class="comment"> * 解释：只要被static synchronized 修饰锁的是class模板, 而 synchronized 锁的是调用的对象</span></span><br><span class="line"><span class="comment"> * 这里是两个锁互不影响，按时间先后执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone6 phone6 = <span class="keyword">new</span> Phone6();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone6.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone6.callPhone();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//睡了3秒</span></span><br><span class="line">        System.out.println(<span class="string">"sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景8：一个 synchronized 实例方法和一个 static synchronized 静态方法，使用两个实例调用：按时间顺序执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个被static+synchronized 修饰的方法和普通的synchronized方法，先执行sendEmail()还是callPhone()？</span></span><br><span class="line"><span class="comment"> * 答案：callPhone()</span></span><br><span class="line"><span class="comment"> * 解释： 只要被 static+synchronized 修饰的锁的就是整个class模板</span></span><br><span class="line"><span class="comment"> * 这里一个锁的是class模板 一个锁的是调用者(对象) ,所以互不影响，按时间顺序执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone8 phoneA = <span class="keyword">new</span> Phone8();</span><br><span class="line">        Phone8 phoneB = <span class="keyword">new</span> Phone8();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phoneA.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phoneB.callPhone();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone8</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>总结：</strong></p>
<p>1、对<strong>普通方法(实例方法)</strong>加 synchronized 锁时，锁的是调用该方法的<strong>实例</strong><br>2、对 <strong>static 修饰的方法(静态方法)</strong>加 synchronized 锁时，锁的是唯一的一个<strong>Class模板</strong>！<br>在我们编写多线程程序的时候，只需要搞明白这个到底锁的是什么就不会出错了！</p>
<p><strong>6. Lock接口：</strong>方法有lock(),unlock(); lock.trylock(); 实现类有：</p>
<ul>
<li><p><strong>RenntrantLock(常用)</strong>：可重入锁；</p>
</li>
<li><p>ReentrantReadWriteLock . ReadLock 读锁；</p>
</li>
<li><p>ReentrantReadWriteLock . WriteLock 写锁；</p>
</li>
</ul>
<p>6.1 RenntrantLock可实现<strong>公平锁与非公平锁</strong>：默认非公平；</p>
<p><img src="https://i.loli.net/2020/08/17/oFZIur7dcCTK2eE.png" alt="image-20200817220020796"></p>
<p>​    使用方法：（手动加锁解锁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Lock mylock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="number">2</span>. mylock.lock();</span><br><span class="line"><span class="number">1</span>. <span class="keyword">try</span>..<span class="keyword">catch</span>..<span class="keyword">finally</span>;<span class="comment">//业务内容</span></span><br><span class="line"><span class="number">2</span>. mylock.unlock();</span><br></pre></td></tr></table></figure>



<p><strong>7. Synchronized 和 RenntrantLock锁的区别：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>Synchronized</strong></th>
<th><strong>RenntrantLock等</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>内置java<strong>关键字</strong></td>
<td><strong>类</strong></td>
</tr>
<tr>
<td>是否<strong>手动</strong></td>
<td><strong>自动</strong>释放</td>
<td><strong>手动</strong>释放,否则死锁</td>
</tr>
<tr>
<td>锁的<strong>状态</strong></td>
<td>无法判断获取锁的状态</td>
<td>可<strong>判断是否获取</strong>到锁</td>
</tr>
<tr>
<td><strong>等待</strong>状态</td>
<td>被动等待</td>
<td>可尝试获取锁：<strong>trylock()</strong></td>
</tr>
<tr>
<td><strong>功能特征</strong></td>
<td>可重入锁,不可中断,非公平</td>
<td>可重入锁,可中断锁,可公平</td>
</tr>
<tr>
<td>适用范围</td>
<td>锁<strong>少量</strong>同步代码</td>
<td>锁<strong>大量</strong>同步代码</td>
</tr>
</tbody></table>
<p><strong>8.  生产者和消费者问题：</strong></p>
<p>线程间的<strong>通信过程</strong>：判断是否等待 -&gt; 执行业务 -&gt; 通知唤醒其他线程</p>
<p><strong>使用传统的synchronized锁实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">//+1 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123; </span><br><span class="line"><span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">this</span>.wait();<span class="comment">//等待 </span></span><br><span class="line">&#125; </span><br><span class="line">	number++; <span class="comment">//执行业务</span></span><br><span class="line">  <span class="keyword">this</span> .notifyA1l(); <span class="comment">//通知其他线程，我+1完毕了 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>wait()</strong> 应该总是出现在<strong>while循环</strong>中，若使用if判断,则可能导致<strong>虚假唤醒</strong>！Example：比如说买货，如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了 ，但是只能一个人买，所以<strong>其他人都是假唤醒，因为获取不到对象的锁</strong>。</p>
<p><strong>注:notify() 和 notifyAll()的区别</strong>:</p>
<p>​        notify()方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，<strong>选择哪个线程取决于操作系统对多线程管理的实现。</strong>notifyAll() 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。</p>
<p><strong>使用JUC实现生产者消费者问题：</strong></p>
<ol>
<li>lock.newCondition();</li>
<li>lock.lock();</li>
<li>使用 condition 的await() ,signal()/signalAll()方法；//根据业务唤醒</li>
<li>lock.unlock();</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	Condition condition = lock.newCondition();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">       		<span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">            	condition.await(); <span class="comment">// 根据条件进入等待</span></span><br><span class="line">            	&#125;</span><br><span class="line">            number++; <span class="comment">// 业务代码</span></span><br><span class="line">            condition.signalAll();<span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与传统锁方法的对比：</p>
<p><img src="https://i.loli.net/2020/08/17/b9KtrUAzHfPjRm5.png" alt="image-20200817231339363"></p>
<p>使用condition监视器的<strong>优势</strong>：<strong>精准地通知和唤醒线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123; <span class="comment">// 资源类 Lock</span></span><br><span class="line">        <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> Condition conditionA = lock.newCondition();</span><br><span class="line">        <span class="keyword">private</span> Condition conditionB = lock.newCondition();</span><br><span class="line">        <span class="keyword">private</span> Condition conditionC = lock.newCondition();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// 1A 2B 3C</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                    conditionA.await();<span class="comment">// 等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                number = <span class="number">2</span>;</span><br><span class="line">                conditionB.signal();<span class="comment">//指定唤醒conditonB监听的线程：B</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                    conditionB.await();</span><br><span class="line">                &#125;</span><br><span class="line">                number = <span class="number">3</span>;</span><br><span class="line">                conditionC.signal();<span class="comment">//指定唤醒conditonC监听的线程：C</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                    conditionC.await();</span><br><span class="line">                &#125;</span><br><span class="line">                number = <span class="number">1</span>;</span><br><span class="line">                conditionA.signal();<span class="comment">//指定唤醒conditonA监听的线程：A</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-ReadWriteLock接口-读写锁-："><a href="#9-ReadWriteLock接口-读写锁-：" class="headerlink" title="9. ReadWriteLock接口 (读写锁)："></a>9. ReadWriteLock接口 (读写锁)：</h3><p>​    方法：readLock(); writeLock(); //可以实现：可单个线程同时写；多个线程同时读(没有线程在写的时候)，</p>
<p>​    实现类：<strong>ReentrantReadWriteLock</strong> ：读写锁。</p>
<p>用这种锁可以实现<strong>更加细粒度的控制，可选择加读锁还是加写锁</strong>：</p>
<p>readLock()可防止在读的时候被写入；【共享锁】：多个读线程可同时持有；</p>
<p>writeLock()可防止在写的时候被读取；【排他锁】：每次只能一个线程持有；</p>
<h3 id="10-集合的线程安全问题："><a href="#10-集合的线程安全问题：" class="headerlink" title="10. 集合的线程安全问题："></a><strong>10. 集合的线程安全问题：</strong></h3><ol>
<li><strong>ArrayList：</strong>多线程下，对ArrayList做出修改，会出现java. util. ConcurrentModificationException  <strong>并发修改异常</strong>！</li>
</ol>
<p>解决方案: </p>
<ul>
<li>使用Collection.SynchronizedArrayList&lt;&gt;(); 直接加同步锁，效率低</li>
<li><strong>使用CopyOnWriteArrayList【写入时复制】</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>COW技术：</strong>开始时内核并不会复制整个地址空间，而是让父子进程共享地址空间，只有在写时才复制地址空间，使得父子进程都拥有独立的地址空间，即资源的复制是在只有需要写入时才会发生。</p>
<p>​    <strong>只有在写入/删除的时候，才会从原来的数据复制一个副本出来，然后修改这个副本，最后把原数据替换成当前的副本。</strong>CopyOnWriteArrayList 比 Vector牛逼在哪？ <strong>只在add/delete方法里用了lock锁；(只有在修改时才加锁)</strong>；</p>
<ol start="2">
<li><strong>HashSet</strong>：多线程下，对HashSet做出修改，会出现java. util. ConcurrentModificationException  <strong>并发修改异常</strong>！</li>
</ol>
<p>解决方案：</p>
<ul>
<li>使用Collection.SynchronizedSet&lt;&gt;(); 直接加同步锁，效率低</li>
<li><strong>使用CopyOnWriteArraySet【写入时复制】</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>注：HashSet底层</strong>：是HashMap实现的：set内的元素就是map中的“key”；value是一个PRESENT常量</p>
<ol start="3">
<li><strong>HashMap：</strong></li>
</ol>
<p>回顾：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity ,factor);</span><br><span class="line"><span class="comment">//构造函数：初始容量，加载因子：默认：16，0.75；</span></span><br></pre></td></tr></table></figure>

<p>多线程下，对HashSet做出修改，会出现java. util. ConcurrentModificationException  <strong>并发修改异常</strong>！</p>
<p>解决方案：</p>
<ul>
<li>使用Collection.SynchronizedMap&lt;&gt;(); 直接加同步锁，效率低</li>
<li><strong>使用ConcurrentHashMap:细化加锁粒度，非整个Map加锁，JDK1.8也摒弃了Segment加锁，直接对Node加锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="11-Callable接口："><a href="#11-Callable接口：" class="headerlink" title="11. Callable接口："></a>11. Callable接口：</h3><p><strong>与runnable接口的区别：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Runnable</th>
<th>Callable</th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>无</td>
<td>返回泛型类型的<strong>返回值</strong></td>
</tr>
<tr>
<td>异常</td>
<td>不能抛出</td>
<td>可抛出已检查<strong>异常</strong></td>
</tr>
<tr>
<td>方法</td>
<td>run()</td>
<td><strong>call()</strong></td>
</tr>
</tbody></table>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> , main(String[] args) &#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread(); </span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(thread); <span class="comment">// 把thread封装进futuretask里面；</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, name: <span class="string">"A"</span>). start(); 	<span class="comment">// 调用futuretask线程</span></span><br><span class="line">        Integer o = (Integer) futureTask. get(); <span class="comment">// 获取Callable线程的返回结果</span></span><br><span class="line">        <span class="comment">//这个get方法可能产生阻塞，因为他要等待结果的产生。要么通过异步通信来获取此结果。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System. out . println(<span class="string">"call()"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>; <span class="comment">//返回值的类型为 Integer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li><p>这个get方法获取结果可能产生阻塞，因为他要等待结果的产生；要么通过异步通信来获取此结果。</p>
</li>
<li><p>这个结果会缓存下来</p>
</li>
</ol>
<h3 id="12-三大常用辅助工具类"><a href="#12-三大常用辅助工具类" class="headerlink" title="12. 三大常用辅助工具类"></a>12. 三大常用辅助工具类</h3><ol>
<li><p><strong>CountDownLatch</strong>：倒数计数器:</p>
<p>每次有线程调用countDownLatch(), 数量-1 , 当计数器变为0 , countDownLatch.await()就会被唤醒,继续执行!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">核心方法：</span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);<span class="comment">//new一个计数器，初始值为6</span></span><br><span class="line">countDownLatch. countDown(); <span class="comment">//计数-1；</span></span><br><span class="line">countDownLatch.await(); <span class="comment">//等待计数器归零，然后再向下执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo:   </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//总数是6，必须要执行任务的时候，再使用!</span></span><br><span class="line">            CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(()-&gt;&#123;System.out.println(Thread.currentThread().getName()+<span class="string">" Go out"</span>);</span><br><span class="line">                    countDownLatch. countDown(); <span class="comment">//数量-1</span></span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch. await(); <span class="comment">//等待计数器归零，然后再向下执行!</span></span><br><span class="line">            System.out.println(<span class="string">"Close Door"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CyclicBarrier:</strong> 循环栅栏</p>
<p>从字面上的意思可以知道，这个类的中文意思是“循环栅栏”。大概的意思就是一个可循环利用的屏障。</p>
<p><strong>它的作用就是会让所有线程都等待完成后才会继续下一步行动</strong>。</p>
<ul>
<li>线程调用 await() 表示自己已经到达栅栏；</li>
<li>当所有线程到达栅栏的数量等于设置的数量（这里是7）时，程序继续往下执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙成功"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+finalI);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();<span class="comment">//等待7次</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Semaphore：信号量</strong></p>
<p>用于<strong>限制可以访问某些资源（物理或逻辑的）的线程数目</strong>：</p>
<p>比如：假如有3个窗口可以打饭，同一时刻也只能有3名同学打饭。第四个人来了之后就必须在外面等着，只要有打饭的同学好了，就可以去相应的窗口了。</p>
<p>用法：acquire()方法、release()方法</p>
<p><img src="https://i.loli.net/2020/08/18/rzWDk2oy86m5bZA.png" alt="image-20200818205829517"></p>
<p><code>acquire()</code>:获取信号量，若获得不到则一直等待直到获得；</p>
<p><code>release（）</code>：释放信号量, 会将当前的可用信号量+ 1 ,然后噪醒等待的线程；</p>
<p>应用场景：多个共享资源互斥的使用!<strong>并发限流,控制最大的线程数</strong></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/" itemprop="url">动态代理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-15T23:43:16+08:00">
                2020-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tags-spring"><a href="#tags-spring" class="headerlink" title="tags:spring"></a>tags:spring</h2><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>​        java动态代理机制中有<strong>两个重要的类和接口InvocationHandler（接口）和Proxy（类）</strong>，这一个类Proxy和接口InvocationHandler是我们实现动态代理的核心；</p>
<h5 id="1-InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述："><a href="#1-InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述：" class="headerlink" title="1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述："></a>1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@code</span> InvocationHandler&#125; is the <span class="class"><span class="keyword">interface</span> <span class="title">implemented</span> <span class="title">by</span></span></span><br><span class="line"><span class="class"><span class="title">the</span> &lt;<span class="title">i</span>&gt;<span class="title">invocation</span> <span class="title">handler</span>&lt;/<span class="title">i</span>&gt; <span class="title">of</span> <span class="title">a</span> <span class="title">proxy</span> <span class="title">instance</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span>&gt;<span class="title">Each</span> <span class="title">proxy</span> <span class="title">instance</span> <span class="title">has</span> <span class="title">an</span> <span class="title">associated</span> <span class="title">invocation</span> <span class="title">handler</span>.</span></span><br><span class="line"><span class="class"><span class="title">When</span> <span class="title">a</span> <span class="title">method</span> <span class="title">is</span> <span class="title">invoked</span> <span class="title">on</span> <span class="title">a</span> <span class="title">proxy</span> <span class="title">instance</span>, <span class="title">the</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"><span class="title">invocation</span> <span class="title">is</span> <span class="title">encoded</span> <span class="title">and</span> <span class="title">dispatched</span> <span class="title">to</span> <span class="title">the</span> </span>&#123;<span class="meta">@code</span> invoke&#125;</span><br><span class="line">method of its invocation handler.</span><br></pre></td></tr></table></figure>

<p>​        每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用，看如下invoke方法：</p>
<h5 id="2-Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。"><a href="#2-Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。" class="headerlink" title="2.Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。"></a>2.Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, </span><br><span class="line">                                        Class&lt;?&gt;[] interfaces, </span><br><span class="line">                                        InvocationHandler h)123</span><br><span class="line"> Returns an instance of a proxy class for the specified interfaces</span><br><span class="line"> that dispatches method invocations to the specified invocation</span><br><span class="line"> handler.  This method is equivalent to:123</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是创建一个代理类对象，它接收三个参数，我们来看下几个参数的含义：</p>
<ul>
<li><strong>loader</strong>：一个<strong>classloader对象</strong>，定义了由哪个classloader对象对生成的代理类进行加载</li>
<li><strong>interfaces</strong>：一个<strong>interface对象数组</strong>，表示我们将要给我们的代理对象提供一组什么样的接口，如果我们提供了这样一个接口对象数组，那么也就是声明了代理类实现了这些接口，代理类就可以调用接口中声明的所有方法。</li>
<li><strong>h</strong>：一个<strong>InvocationHandler对象</strong>，表示的是当动态代理对象调用方法的时候会关联到哪一个InvocationHandler对象上，并最终由其调用。</li>
</ul>
<h5 id="3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法"><a href="#3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法" class="headerlink" title="3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法"></a>3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法</h5><ul>
<li>首先我们定义一个接口People</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个Teacher类，实现People接口，这个类是真实的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师教书育人..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"教书"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在我们要定义一个代理类的<strong>调用处理程序</strong>，每个代理类的调用处理程序都必须<strong>实现InvocationHandler接口</strong>，代理类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理类中的真实对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数，给我们的真实对象赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkHandler</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//在真实的对象执行之前我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before invoke。。。"</span>);</span><br><span class="line">        Object invoke = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//在真实的对象执行之后我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after invoke。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代理类的调用处理程序的invoke方法中的第一个参数proxy好像我们从来没有用过…</p>
<ul>
<li><strong>接下来我们看下客户端类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要代理的真实对象</span></span><br><span class="line">        People people = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">//代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中，最终代理对象的调用处理程序会调用真实对象的方法</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> WorkHandler(people);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数</span></span><br><span class="line"><span class="comment">         * 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口，这样代理对象就能像真实对象一样调用接口中的所有方法</span></span><br><span class="line"><span class="comment">         * 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        People proxy = (People)Proxy.newProxyInstance(handler.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);</span><br><span class="line">        <span class="comment">//System.out.println(proxy.toString());</span></span><br><span class="line">        System.out.println(proxy.work());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before invoke。。。</span><br><span class="line">老师教书育人...</span><br><span class="line">after invoke。。。</span><br><span class="line">教书1234</span><br></pre></td></tr></table></figure>

<p>​    通过上面的讲解和示例动态代理的原理及使用方法，在Spring中的两大核心IOC和AOP中的<strong>AOP(面向切面编程)的思想就是动态代理</strong>，<strong>在代理类的前面和后面加上不同的切面组成面向切面编程。</strong></p>
<p>上面我们只讲解了Proxy中的newProxyInstance（生成代理类的方法），但是它还有其它的几个方法，我们下面就介绍一下：</p>
<ul>
<li>getInvocationHandler：返回指定代理实例的调用处理程序</li>
<li>getProxyClass：给定类加载器和接口数组的代理类的java.lang.Class对象。</li>
<li>isProxyClass：当且仅当使用getProxyClass方法或newProxyInstance方法将指定的类动态生成为代理类时，才返回true。</li>
<li>newProxyInstance：返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/14/Redis%E8%AE%BE%E7%BD%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/14/Redis%E8%AE%BE%E7%BD%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F/" itemprop="url">Redis设置序列化方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-14T00:18:02+08:00">
                2020-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tags-Redis"><a href="#tags-Redis" class="headerlink" title="tags:Redis"></a>tags:Redis</h2><h2 id="Redis设置序列化方式"><a href="#Redis设置序列化方式" class="headerlink" title="Redis设置序列化方式:"></a>Redis设置序列化方式:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改默认的redisTemplate的持久化方式;</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object,Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/11/%E7%A7%92%E6%9D%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/11/%E7%A7%92%E6%9D%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" itemprop="url">秒杀开发笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-11T14:33:57+08:00">
                2020-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="秒杀开发笔记"><a href="#秒杀开发笔记" class="headerlink" title="秒杀开发笔记"></a>秒杀开发笔记</h2><h4 id="SecKill-基于-SpringBoot-Mybatis-Redis的高并发秒杀API"><a href="#SecKill-基于-SpringBoot-Mybatis-Redis的高并发秒杀API" class="headerlink" title="SecKill:基于 SpringBoot+Mybatis+Redis的高并发秒杀API"></a>SecKill:基于 SpringBoot+Mybatis+Redis的高并发秒杀API</h4><ul>
<li><p><strong>业务需求</strong>：</p>
<p>​    此项目模拟的是电商活动中一个商品的高并发秒杀场景。商品列表中有N种商品，每个商品都有自己的库存数目，每个商品的秒杀开始时间也不相同。每个用户只可以秒杀成功一次某种商品，不同的商品可以分别秒杀。</p>
</li>
<li><p><strong>业务逻辑</strong>：</p>
<p><strong>数据优化</strong>：</p>
<ul>
<li><strong>热点数据缓存</strong>：启用SpringBoot的声明式缓存支持，将热门商品信息等热点数据放入Redis缓存，降低服务器压力；</li>
<li><strong>内容分发网络</strong>：使用CDN存储静态资源，解决Tomcat服务器带宽瓶颈；</li>
<li><strong>动静数据分离</strong>：前端采用Freemarker模板引擎将页面静态化，并使用ajax动态加载后端产生的数据。</li>
</ul>
<p><strong>并发优化</strong>：</p>
<ul>
<li><strong>避免超卖</strong>：商品库存信息放入Redis，在Redis缓存中预减库存，完成秒杀用户确权与避免商品超卖问题；</li>
<li><strong>削峰限流</strong>：使用RabbitMQ消息队列，用户秒杀成功确权与订单信息生成这两个过程异步执行，实现削峰限流和业务逻辑解耦。</li>
<li><strong>负载均衡</strong>：使用Nginx反向代理服务器，将用户请求转发到多台服务器，实现负载均衡及更高的并发量；同时使用分布式Session，将 Session转存到Redis中实现 Session 共享访问。</li>
</ul>
<p><strong>安全优化</strong>：</p>
<ul>
<li><p><strong>URL加盐</strong>：后端动态生成商品秒杀的路径，等到商品秒杀的时间获取秒杀路径的接口才会返回秒杀路径；</p>
</li>
<li><p><strong>防刷与反爬</strong>：在Redis中保存当前客户端的访问次数，对于在设定时间内超过访问次数限制的IP，使用AOP拦截器对其拒绝服务。</p>
</li>
<li><p><strong>服务降级和服务熔断</strong>：当某个服务单元发生故障监控，向调用方法返回一个符合预期的、可处理的备选响应。<strong>（未实现）</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h4><ul>
<li>SpringBoot 2.x</li>
<li>Mybatis</li>
<li>Redis</li>
<li>RabbitMQ</li>
<li>Nginx</li>
<li>MySQL</li>
</ul>
<h4 id="1-配置依赖"><a href="#1-配置依赖" class="headerlink" title="1. 配置依赖"></a>1. 配置依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.geekouc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>babytun-seckill<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>babytun-seckill<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapper头模板：</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-分层编写后端和前端页面：-view-gt-controller-gt-service-gt-dao"><a href="#2-分层编写后端和前端页面：-view-gt-controller-gt-service-gt-dao" class="headerlink" title="2. 分层编写后端和前端页面： view -&gt; controller -&gt; service -&gt; dao"></a>2. 分层编写后端和前端页面： view -&gt; controller -&gt; service -&gt; dao</h4><h4 id="3-压力测试：Jmeter"><a href="#3-压力测试：Jmeter" class="headerlink" title="3. 压力测试：Jmeter"></a>3. 压力测试：Jmeter</h4><p>启动命令：sh jmeter</p>
<p><img src="https://i.loli.net/2020/08/11/vBLh8yTw6gGJzqH.png" alt="image-20200811231556871"></p>
<p>模拟100用户、每个用户进行100次访问；</p>
<p>未使用redis缓存时：</p>
<p><img src="https://i.loli.net/2020/08/11/M8bmnruvPWTaezs.png" alt="image-20200811232126997"></p>
<ul>
<li><p><strong>Throughput</strong> <strong>:吞吐量：每秒489次请求</strong></p>
</li>
<li><p>Average/Min/Max 响应时间：192/s</p>
</li>
</ul>
<h3 id="高并发问题分析："><a href="#高并发问题分析：" class="headerlink" title="高并发问题分析："></a>高并发问题分析：</h3><p>​        在电商应用中,90%数据处理是用于<strong>读取</strong>数据,在海量数据的情况下,<strong>数据库</strong>最有可能成为<strong>高并发的瓶颈</strong>。因此<strong>提高数据库效率</strong>戓者<strong>降低数据库交互</strong>就是我们高并发首先要考虑的向题。</p>
<p>​        电商应用中,很大ー部分数据是在一段时间内稳定不变的, 其中很大ー部分数据是一段时间內稳定不变的,例如”商 信息”、””会员信息“、“网站基本信息”等；对于稳定数据,常用两种方式进行高并发处理：</p>
<ul>
<li>利用<strong>缓存</strong>( Redis、 Ehcache、 Memcached..) </li>
<li>利用<strong>静态化技术</strong>(staticize)转化为Html</li>
</ul>
<h4 id="4-静态数据优化：Redis缓存"><a href="#4-静态数据优化：Redis缓存" class="headerlink" title="4. 静态数据优化：Redis缓存"></a>4. 静态数据优化：Redis缓存</h4><p><strong>Redis在Springboot中的使用：</strong></p>
<p><strong>4.1 在主程序中开启声明式缓存注解支持</strong></p>
<p><img src="https://i.loli.net/2020/08/12/tdoGh3carImNRYv.png" alt="image-20200812000958909"></p>
<p><strong>4.2 对service层中的方法,利用@Cacheable注解开启缓存</strong></p>
<p><img src="https://i.loli.net/2020/08/12/AutzQpOKCnRIyJj.png" alt="image-20200812001021759"></p>
<p><strong>4.3 在yml中配置Redis信息：</strong></p>
<p><img src="https://i.loli.net/2020/08/12/N4ksY7B95TtE6Dj.png" alt="image-20200812001736099"></p>
<p><strong>4.4 使用redis后的JMeter吞吐量:</strong></p>
<p><img src="https://i.loli.net/2020/08/12/pLEWIlcMh4FujmO.png" alt="image-20200812005356116"></p>
<h4 id="5-页面静态化技术：-以空间换时间"><a href="#5-页面静态化技术：-以空间换时间" class="headerlink" title="5. 页面静态化技术：[以空间换时间]"></a>5. 页面静态化技术：[以空间换时间]</h4><p>​        页面静态化是指将动态页面(jsp/ freemarker,…)变成html静态页面。<strong>动态页面便于管理</strong>,但是访问网页时还需要程序先处理一遍,所以导致访问速度相对较慢。而<strong>静态页面访问速度快</strong>,却又不便于管理。<strong>静态化可以将两种页面的好处集中到一起</strong>。</p>
<p><img src="https://i.loli.net/2020/08/12/Y3BevfmSyuWcph5.png" alt="image-20200812010528716"></p>
<p>动态生成模板对象：</p>
<p><img src="https://i.loli.net/2020/08/12/V4z5U6iB72oQCAJ.png" alt="image-20200812112335667"></p>
<p>注：可以使用大循环直接对所有商品页面进行静态化即可；</p>
<h4 id="Nginx-反向代理服务器"><a href="#Nginx-反向代理服务器" class="headerlink" title="Nginx(反向代理服务器)"></a>Nginx(反向代理服务器)</h4><p>​        Nginx是一款轻量级的<strong>Web服务器/反向代理服务器</strong>, 其特点是<strong>占内存少,并发能力强</strong>,事实上 nginx的并发能力确实在同类型的网页服务器中表现较好。</p>
<p>安装：brew install nginx</p>
<p>启动：brew services start nginx</p>
<p>路径：/usr/local/etc/nginx/nginx.conf</p>
<p>配置：在39行设置需要映射的根目录</p>
<p><img src="https://i.loli.net/2020/08/12/jgrJukMKb3YQNxf.png" alt="image-20200812131929792"></p>
<p><strong>使用nginx+静态化页面的并发表现：</strong></p>
<p><img src="https://i.loli.net/2020/08/12/dor42AWTXg6Sz93.png" alt="image-20200812133244195"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="静态化后的额外处理："><a href="#静态化后的额外处理：" class="headerlink" title="静态化后的额外处理："></a>静态化后的额外处理：</h4><p><strong>5.1 自动计划任务静态化</strong></p>
<p>使用Springboot的计划任务自动生成静态化页面：        </p>
<p><img src="https://i.loli.net/2020/08/12/7hxvEYtidUk8PQG.png" alt="image-20200812133838882"></p>
<p>找到数据库中上次修改不超过5分钟的数据：</p>
<p><img src="https://i.loli.net/2020/08/12/vypADPTGR1bhqeZ.png" alt="image-20200812135715368"></p>
<p>制定间隔5分钟的计划任务：</p>
<p><img src="https://i.loli.net/2020/08/12/egyAh9nvZfuHIJR.png" alt="image-20200812140403359"></p>
<p><strong>5.2 动静态数据分离：</strong></p>
<p>​    页面静态化执行效率固然高,但往往在页面中也存在动态数据。例如“评论”的内容就一直在不断变化肯定不能对其静态化处理。<strong>遇到这种动态数据需要在静态页面中使用AJAX动态加载后端产生的数据</strong>。</p>
<p>​    <img src="https://i.loli.net/2020/08/12/FRUkviKuDQEgtqN.png" alt="image-20200812141917901"></p>
<ul>
<li>使用ajax 加载动态的评论内容，写在goods.ftlh中：</li>
</ul>
<p><img src="https://i.loli.net/2020/08/12/UFaR3uqochsnTbm.png" alt="image-20200812232744872"></p>
<p>再重新生成全部的nginx静态化页面；</p>
<p>注意：此时，从nginx服务器访问网页，还不能找到对应的评论内容:</p>
<p><img src="https://i.loli.net/2020/08/12/5EvgojeKDYPzJ1U.png" alt="image-20200812234200597"></p>
<p><strong>因此需要配置Nginx代理</strong>：</p>
<p><img src="https://i.loli.net/2020/08/12/GK3D965RzEtbpaC.png" alt="image-20200812235453829"></p>
<p>​        通过此配置可以将 nginx的 /evaluate/页面代理到tomcat服务器的<a href="http://locathost:8080/evaluate" target="_blank" rel="noopener">http://locathost:8080/evaluate</a>; 注意要保持开启tomcat服务器，否则无法成功代理。</p>
<p><strong>总结动静分离的效果：</strong>访问静态化的页面时，如果需要访问动态数据：可以通过配置Nginx代理，将某页面代理到tomcat服务器，实现获取动态数据。</p>
<h4 id="6-秒杀问题分析："><a href="#6-秒杀问题分析：" class="headerlink" title="6. 秒杀问题分析："></a>6. 秒杀问题分析：</h4><p>​        秒杀我们日常开发中最常见的高并发场景。<strong>秒杀的特点</strong>：1）瞬超高访问量;  2)商品总量有限,先到先得;  3)有明确的开始、结束时间。</p>
<p>秒杀活动常见<strong>两个挑战</strong>:</p>
<ul>
<li><strong>高并发:</strong> 基本主流电商的秒杀QPS峰值都在100万+。</li>
<li><strong>避免超卖:</strong> 如何避免购买商品人数不超过商品数量上限,这是要面临的难题。</li>
</ul>
<img src="https://i.loli.net/2020/08/13/JBqLMRbHmCD6SKr.png" alt="image-20200813141732943" style="zoom:50%;" />

<img src="https://i.loli.net/2020/08/13/TxRobN2tv5E1KYM.png" alt="image-20200813141751633 " style="zoom:50%;" />

<p><strong>商品库存count的改变未保证对其他线程的可见性，因此发生超卖问题。</strong></p>
<p>解决方法：有多种方案来解决这个问题，我们主要看3种方案：</p>
<ul>
<li><p>悲观锁：影响性能；</p>
</li>
<li><p>乐观锁：高并发下失败率高，可引入重入机制在失败后重复尝试；</p>
</li>
<li><p><strong>Redis+ Lua</strong></p>
</li>
<li><h4 id="使用Redis预减库存-gt-解决超卖问题："><a href="#使用Redis预减库存-gt-解决超卖问题：" class="headerlink" title="使用Redis预减库存-&gt; 解决超卖问题："></a>使用Redis预减库存-&gt; 解决超卖问题：</h4></li>
</ul>
<p><strong>为什么选择 Redis</strong>：</p>
<ul>
<li>单线程模型</li>
<li>内存存储,高达10WQPS </li>
<li>天生分布式支持</li>
</ul>
<img src="https://i.loli.net/2020/08/13/Na9RSKfYqx7lkQg.png" alt="image-20200813215318480 " style="zoom:50%;" />



<h4 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h4><p><strong>6.1 编写mapper 数据库操作</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//查询出符合秒杀时间的商品：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.geekouc.babytunseckill.dao.PromotionSecKillDAO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUnstartSecKill"</span> <span class="attr">resultType</span>=<span class="string">"com.geekouc.babytunseckill.entity.PromotionSecKill"</span>&gt;</span></span><br><span class="line">        select * from t_promotion_seckill </span><br><span class="line">      	where now() BETWEEN start_time AND end_time and status = 0</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">//更新秒杀状态：</span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"com.geekouc.babytunseckill.entity.PromotionSecKill"</span>&gt;</span></span><br><span class="line">        update t_promotion_seckill</span><br><span class="line">        set goods_id = #&#123;goodsId&#125;,ps_count = #&#123;psCount&#125;,</span><br><span class="line">  					start_time = #&#123;startTime&#125;, end_time = #&#123;endTime&#125;,</span><br><span class="line">            status = #&#123;status&#125;, current_price = #&#123;currentPrice&#125; </span><br><span class="line">  			where ps_id = #&#123;psId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>6.2 秒杀调度任务</strong>：每隔5秒检查符合秒杀时间的商品，使其进入秒杀状态,并将其放入Redis的List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PromotionSecKillDAO promotionSecKillDAO;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">//RedisTemplate是Spring封装的Redis操作类,提供了一系列操作redis的模板方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSecKill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PromotionSecKill&gt; list = promotionSecKillDAO.findUnstartSecKill();</span><br><span class="line">        <span class="keyword">for</span> (PromotionSecKill ps : list) &#123;</span><br><span class="line">          <span class="comment">//删除以前重复的活动任务缓存</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"seckill:count:"</span> + ps.getPsId());</span><br><span class="line">            System.out.println(ps.getPsId() + <span class="string">"秒杀活动已启动 !"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps.getPsCount(); i++) &#123;</span><br><span class="line">              <span class="comment">//有几个库存商品,则初始化几个list对象;list中先存入商品ID;</span></span><br><span class="line">              redisTemplate.opsForList().rightPush(<span class="string">"seckill:count:"</span> + ps.getPsId(),ps.getGoodsId());</span><br><span class="line">            &#125;</span><br><span class="line">            ps.setStatus(<span class="number">1</span>);</span><br><span class="line">            promotionSecKillDAO.update(ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.3 使用Redis实现库存预减</strong>：如果能从秒杀商品队列中获取有效的goodsId,就将psId和对应的userId放入Redis的set中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionSecKillService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PromotionSecKillDAO promotionSecKillDAO;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSecKill</span><span class="params">(Long psId, String userid, Integer num)</span> <span class="keyword">throws</span> SecKillException </span>&#123;</span><br><span class="line">    <span class="comment">//如果能从秒杀商品队列中获取有效的goodsId,就将psId和对应的userId放入Redis的set中;</span></span><br><span class="line">        PromotionSecKill ps = promotionSecKillDAO.findById(psId);</span><br><span class="line">        <span class="keyword">if</span> (ps == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//秒杀活动不存在:</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"该秒杀活动不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ps.getStatus() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"该秒杀活动还未开始!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ps.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"该秒杀活动已结束!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer goodsId = (Integer) redisTemplate.opsForList().leftPop(<span class="string">"seckill:count:"</span> + ps.getPsId());</span><br><span class="line">        <span class="keyword">if</span> (goodsId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先判断用户id的set集合中是否已经存在此id,若已存在则不允许再次抢购</span></span><br><span class="line">            <span class="keyword">boolean</span> isExisted = redisTemplate.opsForSet().isMember(<span class="string">"seckill:users:"</span> + ps.getPsId(), userid);</span><br><span class="line">            <span class="keyword">if</span> (!isExisted) &#123;</span><br><span class="line">                System.out.println(<span class="string">"恭喜"</span> + userid + <span class="string">"抢到商品了,快去下单吧!"</span>);</span><br><span class="line">                redisTemplate.opsForSet().add(<span class="string">"seckill:users:"</span> + ps.getPsId(), userid);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若该用户已抢购过，抛出自定义异常，并再将此商品加回队列的尾部；</span></span><br><span class="line">                redisTemplate.opsForList().rightPush(<span class="string">"seckill:count:"</span> + ps.getPsId(),ps.getGoodsId());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"抱歉,您已经参加过此活动,请勿重复抢购!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"抱歉,该商品已被抢光,下次再来吧!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.4 Controller层</strong>：控制前端页面访问相应页面时调用秒杀方法，并返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    PromotionSecKillService promotionSecKillService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/seckill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">processSecKill</span><span class="params">(Long psid, String userid)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            promotionSecKillService.processSecKill(psid, userid, <span class="number">1</span>);</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"0"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, <span class="string">"success"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecKillException e) &#123;</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"500"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.5</strong> 设置前端seckill.html的抢购按钮入口，告诉用户抢购结果：</p>
<p><img src="https://i.loli.net/2020/08/14/1PCdutoH9sNxJDK.png" alt="image-20200814175009551"></p>
<p><strong>6.6</strong> 秒杀活动结束后：</p>
<p>将此秒杀任务状态设为已过期,并更新此状态,并清除redis中已过秒杀时间的商品：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endSecKill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PromotionSecKill&gt; psList = promotionSecKillDAO.findExpireSecKill();</span><br><span class="line">        <span class="keyword">for</span> (PromotionSecKill ps : psList) &#123;</span><br><span class="line">            System.out.println(ps.getPsId()+<span class="string">"秒杀活动已结束!"</span>);</span><br><span class="line">            <span class="comment">//秒杀结束后,将此秒杀任务状态设为已过期,并更新此状态</span></span><br><span class="line">            ps.setStatus(<span class="number">2</span>);</span><br><span class="line">            promotionSecKillDAO.update(ps);</span><br><span class="line">            <span class="comment">//删除redis中已过秒杀时间的商品;</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"seckill:count"</span> + ps.getPsId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-使用RabbitMQ：削峰、限流"><a href="#7-使用RabbitMQ：削峰、限流" class="headerlink" title="7. 使用RabbitMQ：削峰、限流"></a>7. 使用RabbitMQ：削峰、限流</h4><img src="https://i.loli.net/2020/08/15/tskMaEXieUHcpBD.png" alt="image-20200815003046510" style="zoom:50%;" />





<img src="https://i.loli.net/2020/08/15/M5pc3rfOYlAHmX4.png" alt="image-20200815003054692 " style="zoom:50%;" />

<img src="https://i.loli.net/2020/08/15/PyB7XD2A4kaS3wJ.png" alt="image-20200815140119283 " style="zoom:50%;" />

<p>7.0 配置好RabbitMQ的环境，创建一个Exchange和一个队列；</p>
<p>7.1 编写Service <strong>向MQ队列发送订单号（速度快）</strong>，并在Controller层调用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendOrderToQueue</span><span class="params">(String userid)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备向队列发送信息..."</span>);</span><br><span class="line">        <span class="comment">//订单基本信息;</span></span><br><span class="line">        HashMap&lt;String,String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">"userid"</span>,userid);</span><br><span class="line">        String orderNo = UUID.randomUUID().toString();</span><br><span class="line">        data.put(<span class="string">"orderNo"</span>,orderNo);</span><br><span class="line">        <span class="comment">//可附加额外的订单信息,如电话 地址等;</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"exchange-order"</span>,<span class="keyword">null</span>,data);</span><br><span class="line">        <span class="keyword">return</span> orderNo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/seckill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">processSecKill</span><span class="params">(Long psid, String userid)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            promotionSecKillService.processSecKill(psid, userid, <span class="number">1</span>);</span><br><span class="line">            String orderNo = promotionSecKillService.sendOrderToQueue(userid);</span><br><span class="line">            HashMap&lt;String,String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            data.put(<span class="string">"orderNo"</span>,orderNo); <span class="comment">//生成订单编号</span></span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"0"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, <span class="string">"success"</span>);</span><br><span class="line">            result.put(<span class="string">"data"</span>,data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecKillException e) &#123;</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"500"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7.2 同时，将<strong>生成的订单号利用ajax回调给前端（速度快）</strong>：</p>
<img src="https://i.loli.net/2020/08/15/qsf5XM6z1ovdJKN.png" alt="image-20200815114423021 " style="zoom:50%;" />

<p>7.3 <strong>配置Rabbit消费者信息</strong>，并新建一个消费者类：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">listener:</span></span><br><span class="line">    <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#定义消费者最多同时处理10个消息</span></span><br><span class="line">      <span class="attr">prefetch:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment">#消息手动确认</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p>7.4 @RabbitHandler注解：<strong>自动从RabbitMQ队列中获取订单号，并实例化一个订单写入数据库中（速度慢）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderDAO orderDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(    <span class="comment">//绑定创建好的rabbitmq交换机和队列</span></span><br><span class="line">            bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">                  value = <span class="meta">@Queue</span>(value = <span class="string">"queue-order"</span>),</span><br><span class="line">                  exchange = <span class="meta">@Exchange</span>(value = <span class="string">"exchange-order"</span>,type = <span class="string">"fanout"</span>)</span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@RabbitHandler</span>  <span class="comment">//消费者获取订单数据,插入到数据库中;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@Payload Map&lt;String,Object&gt; data, Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                              @Headers  Map&lt;String,Object&gt; headers)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========获取到订单数据"</span>+data+<span class="string">"========"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//sleep 500ms,模拟对接支付、物流系统、日志登记...</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Order order = <span class="keyword">new</span> Order();</span><br><span class="line">            order.setOrderNo(data.get(<span class="string">"orderNo"</span>).toString());</span><br><span class="line">            order.setOrderStatus(<span class="number">0</span>);</span><br><span class="line">            order.setUserid(data.get(<span class="string">"userid"</span>).toString());</span><br><span class="line">            order.setRecvName(<span class="string">"xxx"</span>);</span><br><span class="line">            order.setRecvAddress(<span class="string">"xxx"</span>);</span><br><span class="line">            order.setRecvMobile(<span class="string">"138********"</span>);</span><br><span class="line">            order.setAmount(<span class="number">19.8f</span>);</span><br><span class="line">            order.setPostage(<span class="number">0f</span>);</span><br><span class="line">            order.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            orderDAO.insert(order);</span><br><span class="line">            Long tag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">            channel.basicAck(tag,<span class="keyword">false</span>);<span class="comment">//消息确认,false:只进行单个接收 不进行批量接收</span></span><br><span class="line">            System.out.println(data.get(<span class="string">"orderNo"</span>+<span class="string">"订单已创建"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.5 由于生产者和消费者是异步的关系，因此创建一个”正在创建订单,请稍后…”的页面，作为过渡：</p>
<img src="https://i.loli.net/2020/08/15/kTVd79Kz4Pyhmnr.png" alt="image-20200815145349034 " style="zoom:50%;" />

<p>同时，<strong>检查订单号是否已经在数据库中成功生成</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查订单号是否已经在数据库中成功生成</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/checkorder"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">checkOrder</span><span class="params">(String orderNo)</span></span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    Order order = promotionSecKillService.checkOrder(orderNo);</span><br><span class="line">    <span class="keyword">if</span>(order != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//代表订单已在数据库中创建好了</span></span><br><span class="line">        mav.addObject(<span class="string">"order"</span>,order);</span><br><span class="line">        mav.setViewName(<span class="string">"/order"</span>);</span><br><span class="line">        <span class="comment">//跳转到order页面,显示订单信息;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        mav.addObject(<span class="string">"orderNo"</span>,orderNo);</span><br><span class="line">        mav.setViewName(<span class="string">"/waiting"</span>);</span><br><span class="line">        <span class="comment">//跳转到等待页面...在等待页面等待三秒后再次尝试检查订单号...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-Nginx-负载均衡"><a href="#8-Nginx-负载均衡" class="headerlink" title="8. Nginx 负载均衡"></a>8. Nginx 负载均衡</h4><img src="https://i.loli.net/2020/08/15/ovnwH7kT5FK3g1P.png" alt="image-20200815155440698 " style="zoom:50%;" />

<p>Nginx<strong>六种负载均衡策略</strong>：</p>
<ul>
<li><strong>Default - 轮询策略</strong> </li>
<li><strong>Least connected - 最少连接策略</strong></li>
<li><strong>Weighted - 权重策略</strong></li>
<li><strong>IP Hash - IP绑定策略</strong> ：高并发下不推荐使用，因为会使负载不均衡</li>
<li>fair-按响应时间(第三方) </li>
<li>url hash-url分配策略(第三方)</li>
</ul>
<p><strong>8.1 使用Nginx代理后端服务器</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#后端服务器池</span><br><span class="line">upstream babytun &#123;</span><br><span class="line">	#least_conn; #最少连接策略</span><br><span class="line">	#ip_hash;	#ip_hash策略</span><br><span class="line"></span><br><span class="line">	server 192.168.1.3:8001 weight&#x3D;5; #按照权重分配</span><br><span class="line">	server 192.168.1.3:8002 weight&#x3D;2;</span><br><span class="line">	server 192.168.1.3:8003 weight&#x3D;1;</span><br><span class="line">	server 192.168.1.3:8004 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">		#nginx通过80端口提供服务</span><br><span class="line">    listen       80;  </span><br><span class="line">    #使用babytun服务器池进行后端处理</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">    	proxy_pass http:&#x2F;&#x2F;babytun;</span><br><span class="line">    	proxy_set_header Host $host;</span><br><span class="line">    	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        配置完成后，只需访问192.168.1.3/goods?gid=1234 即可访问我们的页面，nginx默认按照轮询策略在4台server之间切换服务器。</p>
<p><strong>8.2 Nginx分布式Session同步问题：</strong></p>
<p>​        例如使用Nginx负载均衡时,用户登录后,再刷新页面可能会代理到另一台server,而此台server没有之前的session,从而导致丢失登录状态。</p>
<p><strong>解决办法</strong>：<strong>将 Session转存到 Redis中实现 Session 共享访问</strong>:</p>
<p><img src="https://i.loli.net/2020/08/15/vSYuaK24FeN63yi.png" alt="image-20200815215155079 "></p>
<ul>
<li>pom中引入Spring-Session依赖以及Redis依赖</li>
<li>主程序启用@EnableRedisHttpSession即可；</li>
</ul>
<p><strong>Spring-Session将自动监听Session，并将其保存到Redis中</strong>！</p>
<p>​        这样，用户登录上去之后，之后无论是再代理到哪台服务器都会一直拥有这个Session,从而保持登录状态。</p>
<h4 id="9-Nginx缓存静态资源降低Tomcat压力："><a href="#9-Nginx缓存静态资源降低Tomcat压力：" class="headerlink" title="9. Nginx缓存静态资源降低Tomcat压力："></a>9. Nginx缓存静态资源降低Tomcat压力：</h4><p><strong>9.1 图片、样式等静态资源</strong>不再经过Tomcat服务器，直接由Nginx服务器指向指定文件夹：</p>
<img src="https://i.loli.net/2020/08/16/7wy9ZbANBcmxMpz.png" alt="image-20200816002658224 " style="zoom:50%;" />

<p>在/usr/local/etc/nginx/nginx.conf中修改配置即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#临时文件夹</span><br><span class="line">    proxy_temp_path &#x2F;Users&#x2F;tianjirong&#x2F;Documents&#x2F;babytun-lb&#x2F;nginx-temp;</span><br><span class="line">    #设置缓存目录;</span><br><span class="line">    #levels代表采用1:2,即采用两级目录的形式保存静态缓存文件，同时文件名进行了MD5编码;</span><br><span class="line">    #keys_zone 定义缓存名称 以及 内存大小使用100M交换空间;</span><br><span class="line">    #如果某个缓存文件超过7天未使用,则删除之;</span><br><span class="line">    #文件夹最大不超过20g,超过后自动删除访问频率最低的缓存文件;</span><br><span class="line">    proxy_cache_path &#x2F;Users&#x2F;tianjirong&#x2F;Documents&#x2F;babytun-lb&#x2F;nginx-cache levels&#x3D;1:2 keys_zone&#x3D;babytun-cache:100m inactive&#x3D;7d max_size&#x3D;20g;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	#nginx通过80端口提供服务</span><br><span class="line">    listen       80;  </span><br><span class="line"></span><br><span class="line">    #静态资源缓存,利用正则表达式匹配url,匹配成功的则执行内部逻辑,~*表示不区分大小写:</span><br><span class="line">    location ~* \.(gif|jpg|css|png|js|woff|html)(.*)&#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;babytun;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_cache babytun-cache;</span><br><span class="line">        #如果资源相应状态码为200-&gt;成功; 302-&gt;暂时性重定向时,资源缓存文件有效期1天;</span><br><span class="line">        proxy_cache_valid 200 302 24h;</span><br><span class="line">        proxy_cache_valid 301 24h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意：当需要缓存<strong>.html</strong>的页面时，需要保证该页面是不经常变动的，否则不应该缓存它。</p>
<p><strong>9.2 Nginx使用Gzip资源压缩：节省带宽</strong>：</p>
<ul>
<li>利用浏览器支持的Gzip压缩, <strong>nginx打包压缩并传输 css、js等静态资源</strong>,可将带宽压力降低30%~70%</li>
</ul>
<p><img src="https://i.loli.net/2020/08/16/5TFjhuVRGq314zd.png" alt="image-20200816132844932"></p>
<p>在/usr/local/etc/nginx/nginx.conf中开启Gzip即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#开启nginx Gzip压缩</span><br><span class="line">gzip  on;</span><br><span class="line">#超过1K的文件才压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line">#压缩哪些类型:对文本类型压缩效果很好 对图片效果不好</span><br><span class="line">gzip_types text&#x2F;plain application&#x2F;javascript text&#x2F;css application&#x2F;x-javascript;</span><br><span class="line">#当使用低版本IE浏览器时禁用压缩</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">#压缩使用的缓存,每个内存也为4K,申请32倍;一般这样写就可以</span><br><span class="line">gzip_buffers 32 4k;</span><br><span class="line">#最重要: 设置压缩级别: 1-9 越大压缩比越高,但浪费CPU资源,建议1-4即可</span><br><span class="line">gzip_comp_level 1;</span><br></pre></td></tr></table></figure>

<p><strong>9.3 使用CDN：解决带宽瓶颈、加速访问速度</strong></p>
<p>​        可将整个layui文件夹上传到CDN中,这样传输这些资源的时候,流量就不会走本地服务器,而是直接走CDN的服务器,实现解决带宽瓶颈和加速访问速度！</p>
<p><strong>使用方法</strong>：</p>
<ul>
<li>开通阿里云等<strong>OSS</strong>服务,向OSS中上传我们的资源</li>
<li>开通阿里云<strong>CDN</strong>服务,将OSS中的资源分发到各个CDN服务器</li>
<li>将自己的<strong>域名绑定映射</strong>到CDN服务器</li>
<li>在前端页面中将所用资源的本地路径改为自己域名中的<strong>远程路径</strong>即可</li>
</ul>
<h4 id="10-流量防刷与反爬虫："><a href="#10-流量防刷与反爬虫：" class="headerlink" title="10. 流量防刷与反爬虫："></a>10. 流量防刷与反爬虫：</h4><p><strong>实现思路</strong>：</p>
<ul>
<li><p>Redist提供了TTL有效期特性(<strong>设置超时时间</strong>)</p>
</li>
<li><p>对于每一个用户,<strong>在 Redisi记录访向次数</strong>：</p>
<p>例如​ key:188.38.12.33  value:39 超时时间:60s</p>
</li>
<li><p><strong>用户每访问1次,对应计数器+1</strong>,超过上限(30)则停止服务</p>
</li>
<li><p>如计数器<strong>超过100则认为爬虫攻击</strong>,永久加入黑名单</p>
</li>
<li><p>1分钟后key销毁,重新开始计数</p>
</li>
</ul>
<p><strong>实现过程</strong>：</p>
<ol>
<li>编写SpringBoot的AOP拦截器,</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AOP拦截器功能:流量防刷</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntiRefreshInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">//RedisTemplate,用于筒化 Redis操作,在IOC容器中自动被初始化</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>); <span class="comment">//设置提示信息的字符集</span></span><br><span class="line">        String clientIp = request.getRemoteAddr();<span class="comment">//获取客户端IP</span></span><br><span class="line">        String userAgent = request.getHeader(<span class="string">"User-Agent"</span>);<span class="comment">//获取客户端浏览器信息</span></span><br><span class="line">        String client = <span class="string">"anti-refresh:"</span> + DigestUtils.md5Hex(clientIp + <span class="string">"_"</span> + userAgent);<span class="comment">//用MD5摘要来标识一个用户</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//若此IP在黑名单中,则直接返回false;</span></span><br><span class="line">        <span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">"anti-refresh:blackList"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(redisTemplate.opsForSet().isMember(<span class="string">"anti-refresh:blackList"</span>,client))&#123;</span><br><span class="line">                response.getWriter().println(<span class="string">"检测到您的IP访问异常,您已被加入黑名单!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer num = (Integer) redisTemplate.opsForValue().get(client);<span class="comment">//记录1分钟内的访问次数</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span>)&#123;<span class="comment">//第一次访问</span></span><br><span class="line">            redisTemplate.opsForValue().set(client,<span class="number">1</span>,<span class="number">60</span>, TimeUnit.SECONDS); <span class="comment">//放入redis,有效期60S</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">20</span> &amp;&amp; num &lt; <span class="number">40</span>)&#123;</span><br><span class="line">                response.getWriter().println(<span class="string">"请求过于频繁,请1分钟后重试!"</span>);</span><br><span class="line">                redisTemplate.opsForValue().increment(client,<span class="number">1</span>); <span class="comment">//每访问一次redis的值+1;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">40</span>)&#123;</span><br><span class="line">                redisTemplate.opsForSet().add(<span class="string">"anti-refresh:blackList"</span>,clientIp);</span><br><span class="line">                response.getWriter().println(<span class="string">"检测到您的IP访问异常,您已被加入黑名单!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"IP"</span>+clientIp+<span class="string">"访问异常,已被加入黑名单!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.opsForValue().increment(client,<span class="number">1</span>); <span class="comment">//每访问一次redis的值+1;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注入拦截器：写一个@Configuration类即可.可选择需要拦截的页面,如:”/goods”</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AntiRefreshInterceptor antiRefreshInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//注入拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(antiRefreshInterceptor).addPathPatterns(<span class="string">"/goods"</span>);<span class="comment">//作用的URL;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/%E7%A7%8B%E6%8B%9B%E5%BE%85%E6%8A%95%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/10/%E7%A7%8B%E6%8B%9B%E5%BE%85%E6%8A%95%E9%80%92/" itemprop="url">秋招待投递</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-10T22:42:42+08:00">
                2020-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="秋招待投递："><a href="#秋招待投递：" class="headerlink" title="秋招待投递："></a>秋招待投递：</h2><p>广汽丰田： <a href="https://gac-toyota.zhiye.com/CAMPUS" target="_blank" rel="noopener">https://gac-toyota.zhiye.com/CAMPUS</a></p>
<p>长虹： 长虹研究院 – Java工程师（成都）<a href="http://campus.51job.com/ch2021/" target="_blank" rel="noopener">http://campus.51job.com/ch2021/</a></p>
<p>小米：<a href="https://app.mokahr.com/campus_apply/xiaomi/24517#/job/109cb990-dd53-47b8-9846-90d3b2b1fcc1" target="_blank" rel="noopener">https://app.mokahr.com/campus_apply/xiaomi/24517#/job/109cb990-dd53-47b8-9846-90d3b2b1fcc1</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/08/Redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/08/Redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/" itemprop="url">Redis之事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-08T22:07:36+08:00">
                2020-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Redis之事务"><a href="#1-Redis之事务" class="headerlink" title="1. Redis之事务"></a>1. Redis之事务</h2><p><strong>Redis事务的概念：</strong></p>
<p>　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>　　总结：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　</p>
<p><strong>Redis事务没有隔离级别的概念：</strong></p>
<p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
<p><strong>Redis不保证原子性：</strong></p>
<p>　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<p><strong>Redis事务的三个阶段：</strong></p>
<ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<p><strong>Redis事务相关命令：</strong></p>
<p>　　watch key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</p>
<p>　　multi : 标记一个事务块的开始（ queued ）</p>
<p>　　exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</p>
<p>　　discard : 取消事务，放弃事务块中的所有命令</p>
<p>　　unwatch : 取消watch对所有key的监控</p>
<h2 id="事务的案例："><a href="#事务的案例：" class="headerlink" title="事务的案例："></a>事务的案例：</h2><p><img src="https://i.loli.net/2020/08/08/QgK91xnCWOUVBJX.png" alt="image-20200808220258106"></p>
<p><img src="https://i.loli.net/2020/08/08/eUFzTowvlXr89DQ.png" alt="image-20200808220315726"></p>
<p><img src="https://i.loli.net/2020/08/08/Hx8Q9wC6e5smhut.png" alt="image-20200808220323889"></p>
<p><img src="https://i.loli.net/2020/08/08/3tKf4p9G7dPnYEJ.png" alt="image-20200808220336464"></p>
<h2 id="使用watch乐观锁的案例"><a href="#使用watch乐观锁的案例" class="headerlink" title="使用watch乐观锁的案例"></a>使用watch乐观锁的案例</h2><p><img src="https://i.loli.net/2020/08/08/zCeULYA8B5FQmPp.png" alt="image-20200808220441009"></p>
<p><img src="https://i.loli.net/2020/08/08/rZD64lAjXRBHUF8.png" alt="image-20200808220646701"></p>
<p><strong>总结：</strong></p>
<p>​        watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/08/Redis%E4%B9%8BHyperLogLog%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/08/Redis%E4%B9%8BHyperLogLog%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" itemprop="url">Redis之HyperLogLog与布隆过滤器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-08T21:09:27+08:00">
                2020-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redis的HyperLogLog与布隆过滤器"><a href="#redis的HyperLogLog与布隆过滤器" class="headerlink" title="redis的HyperLogLog与布隆过滤器"></a>redis的HyperLogLog与布隆过滤器</h2><p>​        首先，HyperLogLog与布隆过滤器都是针对大数据统计存储应用场景下的知名算法。HyperLogLog是在大数据的情况下关于数据基数的空间复杂度优化实现，布隆过滤器是在大数据情况下关于检索一个元素是否在一个集合中的空间复杂度优化后的实现。在传统的数据量比较低的应用服务中，我们要实现数据基数和数据是否存在分析的功能，通常是简单的把所有数据存储下来，直接count一下就是基数了，而直接检索一个元素是否在一个集合中也很简单。</p>
<p>​        但随着数据量的急剧增大，传统的方式已经很难达到工程上的需求。过大的数据量无论是在存储还是在查询方面都存在巨大的挑战，无论我们是用位存储还是树结构存储等方式来优化，都没法达到大数据时代的要求或者是性价比太低。</p>
<p>​        于是HyperLogLog与布隆过滤器这两个算法就很好的派上了用场。他们的使用可以极大的节约存储空间，作为代价，则是牺牲了一个小概率的准确性，这可以很好的达到工程上的需求，对于那些要求准确度没那么高，但数据量巨大的需求是非常合适的。</p>
<p><strong>HyperLogLog原理</strong></p>
<p>​        最直白的解释是，给定一个集合 S，对集合中的每一个元素，我们做一个哈希，假设生成一个 16 位的比特串，从所有生成的比特串中挑选出前面连续 0 次数最多的比特串，假设为 0000000011010110，连续 0 的次数为 8，因此我们可以估计该集合 S 的基数为 2^9。当然单独用这样的单一估计偶然性较大，导致误差较大，因此在实际的 HyperLogLog 算法中，采取分桶平均原理了来消除误差。</p>
<p><strong>特点</strong>：实现<strong>牺牲了一定的准确度</strong>（在一些场景下是可以忽略的），但却实现了<strong>空间复杂度上的极大的压缩</strong>，可以说是性价比很高的。虽然基数不完全准确，但是可以符合，随着数量的递增，基数也是递增的。</p>
<p><strong>布隆过滤器原理</strong></p>
<p><img src="https://i.loli.net/2020/08/08/DkTrtSgCYmuWyqR.png" alt="image-20200808210404433"></p>
<p>​        <strong>布隆过滤器</strong>（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k，以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置为0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，<strong>这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1</strong>。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。<strong>如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中</strong>。注意：此处不能判断该元素是否一定存在集合中，可能<strong>存在一定的误判率</strong>。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p>
<p><strong>特点：巧妙的使用hash算法和bitmap位存储的方式，极大的节约了空间。</strong></p>
<p>​        由于主要用的是hash算法的特点，所有满足和hash算法相同的规则：当过滤器返回 true时（表示很有可能该值是存在的），有一定概率是误判的，即可能不存在；当过滤器返回false时（表示确定不存在），是可以完全相信的。</p>
<p>​        我们换个数据的角度来看规则：当数据添加到布隆过滤器中时，对该数据的查询一定会返回true；当数据没有插入过滤器时，对该数据的查询大部分情况返回false，但有小概率返回true，也就是误判。</p>
<p>　     我们知道它最终满足的规则和hash的规则是一致的，只是组合了多个hash，使用了bitmap来存储，大大优化了存储的空间和判断的效率。</p>
<p><strong>redis中的HyperLogLog</strong></p>
<p>在redis中对HyperLogLog 的支持早在2.8.9的时候就有了。它的操作非常简单</p>
<ul>
<li><a href="http://redisdoc.com/hyperloglog/pfadd.html" target="_blank" rel="noopener">PFADD</a> 给HyperLogLog添加值</li>
<li><a href="http://redisdoc.com/hyperloglog/pfcount.html" target="_blank" rel="noopener">PFCOUNT</a> 获取基数</li>
<li><a href="http://redisdoc.com/hyperloglog/pfmerge.html" target="_blank" rel="noopener">PFMERGE</a> 合并两个HyperLogLog数据（完美合并，分别添加和统一添加的结果是一致的）</li>
</ul>
<p><strong>redis中的布隆过滤器</strong></p>
<p>​        在redis中的布隆过滤器的支持是在redis4.0后支持插件的情况下，通过插件的方式实现的 ，redis的布隆过滤器插件地址：<a href="https://github.com/RedisLabsModules/rebloom" target="_blank" rel="noopener">https://github.com/RedisLabsModules/rebloom</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;size&#125;   </span><br><span class="line"><span class="comment">//创建一个布隆过滤器,key为redis存储键值，error_rate 为错误率</span></span><br><span class="line">BF.ADD &#123;key&#125; &#123;item&#125;  </span><br><span class="line"><span class="comment">//添加值到布隆过滤器中（当过滤器不存在的时候会，会以默认值自动创建一个，建议最好提前创建好）</span></span><br><span class="line">BF.EXISTS &#123;key&#125; &#123;item&#125;  </span><br><span class="line"><span class="comment">//判断值是否存在过滤器中: true（表示很可能存在） false （表示绝对不存在）</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/06/LeetCode%20%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/06/LeetCode%20%E5%9B%9E%E6%BA%AF%E6%B3%95/" itemprop="url">LeetCode 回溯法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-06T21:04:17+08:00">
                2020-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%B7%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="回溯法解题框架："><a href="#回溯法解题框架：" class="headerlink" title="回溯法解题框架："></a>回溯法解题框架：</h3><p><strong>回溯法有3种题型：</strong></p>
<ol>
<li><p>find a path to success;</p>
</li>
<li><p>find all path to success : </p>
<p>2.1 求解的个数；</p>
<p>2.2 求所有的解；【重点】</p>
</li>
<li><p>find the best path to success;</p>
</li>
</ol>
<p><strong>框架：</strong></p>
<p>result = [];</p>
<p>def backTracc(path,选择列表)：</p>
<p>​    if(满足剪枝条件): 剪枝，return；</p>
<p>​    if(满足结果条件)：result.add(path); return;</p>
<p>for 选择 in 选择列表：</p>
<p>​    做选择;</p>
<p>​    backTrace(路径，选择列表);  //进入下一层决策树；</p>
<p>​    撤销选择;</p>
<p>具体情况优化：</p>
<p>【1】当path为StringBulider时，可严格按照上述流程来写。当path为String时，由于String是final修饰的，因此可以省略撤销选择的过程，因为循环中的每次递归用的都是新的变量，与原变量无关，因此不需要对原变量进行撤销选择的操作。（缺点：每次递归都要建立一个新变量）</p>
<p>LeetCode17：电话号码的字母组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 电话号码的字母组合17 </span>&#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    HashMap&lt;Character, String&gt; map; <span class="comment">//用于映射数字和对应的字母</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;  <span class="comment">//特判</span></span><br><span class="line"></span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        map.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        map.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        map.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        map.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        map.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        map.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        map.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line"></span><br><span class="line">        backTrack(digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//digits:一串数字,如:234</span></span><br><span class="line">    <span class="comment">//index:第几位数字:如 2</span></span><br><span class="line">    <span class="comment">//letters:组成的字母:如 adg</span></span><br><span class="line">    <span class="comment">//index:需要递归的数字索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(String digits, <span class="keyword">int</span> index, StringBuilder letters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == index) &#123;   <span class="comment">//满足结束条件</span></span><br><span class="line">            res.add(letters + <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String alphas = map.get(digits.charAt(index));<span class="comment">//获取"abc"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">0</span>; i &lt; alphas.length(); ++i) &#123;</span><br><span class="line">            letters.append(alphas.charAt(i));       <span class="comment">//做选择:将当前字母添加到路径</span></span><br><span class="line">            backTrack(digits, index + <span class="number">1</span>, letters); <span class="comment">//进入下一层决策树</span></span><br><span class="line">            letters.deleteCharAt(letters.length() - <span class="number">1</span>);<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>LeetCode22：括号生成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        backTrace(n,<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> n,String path,<span class="keyword">int</span> numLeft,<span class="keyword">int</span> numRight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRight &gt; numLeft || numLeft &gt; n || numRight &gt; n)    <span class="keyword">return</span>;<span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(numLeft == n &amp;&amp; numRight == n)&#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrace(n,path+<span class="string">"("</span>,numLeft+<span class="number">1</span>,numRight);</span><br><span class="line">        backTrace(n,path+<span class="string">")"</span>,numLeft,numRight+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">田济荣</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jirong0214" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:geekouc@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://i.loli.net/2020/07/09/PqjnfpmXblhDYOJ.jpg" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-wechat"></i>Wechat</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">田济荣</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
