<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="GeekOUC">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="GeekOUC">
<meta property="article:author" content="田济荣">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>GeekOUC</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?345da8a17ad1f3825bc080f35df3590b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GeekOUC</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-简历">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            简历
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/" itemprop="url">动态代理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-15T23:43:16+08:00">
                2020-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tags-spring"><a href="#tags-spring" class="headerlink" title="tags:spring"></a>tags:spring</h2><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>​        java动态代理机制中有<strong>两个重要的类和接口InvocationHandler（接口）和Proxy（类）</strong>，这一个类Proxy和接口InvocationHandler是我们实现动态代理的核心；</p>
<h5 id="1-InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述："><a href="#1-InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述：" class="headerlink" title="1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述："></a>1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。看下官方文档对InvocationHandler接口的描述：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@code</span> InvocationHandler&#125; is the <span class="class"><span class="keyword">interface</span> <span class="title">implemented</span> <span class="title">by</span></span></span><br><span class="line"><span class="class"><span class="title">the</span> &lt;<span class="title">i</span>&gt;<span class="title">invocation</span> <span class="title">handler</span>&lt;/<span class="title">i</span>&gt; <span class="title">of</span> <span class="title">a</span> <span class="title">proxy</span> <span class="title">instance</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span>&gt;<span class="title">Each</span> <span class="title">proxy</span> <span class="title">instance</span> <span class="title">has</span> <span class="title">an</span> <span class="title">associated</span> <span class="title">invocation</span> <span class="title">handler</span>.</span></span><br><span class="line"><span class="class"><span class="title">When</span> <span class="title">a</span> <span class="title">method</span> <span class="title">is</span> <span class="title">invoked</span> <span class="title">on</span> <span class="title">a</span> <span class="title">proxy</span> <span class="title">instance</span>, <span class="title">the</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"><span class="title">invocation</span> <span class="title">is</span> <span class="title">encoded</span> <span class="title">and</span> <span class="title">dispatched</span> <span class="title">to</span> <span class="title">the</span> </span>&#123;<span class="meta">@code</span> invoke&#125;</span><br><span class="line">method of its invocation handler.</span><br></pre></td></tr></table></figure>

<p>​        每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用，看如下invoke方法：</p>
<h5 id="2-Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。"><a href="#2-Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。" class="headerlink" title="2.Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。"></a>2.Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, </span><br><span class="line">                                        Class&lt;?&gt;[] interfaces, </span><br><span class="line">                                        InvocationHandler h)123</span><br><span class="line"> Returns an instance of a proxy class for the specified interfaces</span><br><span class="line"> that dispatches method invocations to the specified invocation</span><br><span class="line"> handler.  This method is equivalent to:123</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是创建一个代理类对象，它接收三个参数，我们来看下几个参数的含义：</p>
<ul>
<li><strong>loader</strong>：一个<strong>classloader对象</strong>，定义了由哪个classloader对象对生成的代理类进行加载</li>
<li><strong>interfaces</strong>：一个<strong>interface对象数组</strong>，表示我们将要给我们的代理对象提供一组什么样的接口，如果我们提供了这样一个接口对象数组，那么也就是声明了代理类实现了这些接口，代理类就可以调用接口中声明的所有方法。</li>
<li><strong>h</strong>：一个<strong>InvocationHandler对象</strong>，表示的是当动态代理对象调用方法的时候会关联到哪一个InvocationHandler对象上，并最终由其调用。</li>
</ul>
<h5 id="3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法"><a href="#3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法" class="headerlink" title="3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法"></a>3动态代理中核心的两个接口和类上面已经介绍完了，接下来我们就用实例来讲解下具体的用法</h5><ul>
<li>首先我们定义一个接口People</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个Teacher类，实现People接口，这个类是真实的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师教书育人..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"教书"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在我们要定义一个代理类的<strong>调用处理程序</strong>，每个代理类的调用处理程序都必须<strong>实现InvocationHandler接口</strong>，代理类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理类中的真实对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数，给我们的真实对象赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkHandler</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//在真实的对象执行之前我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before invoke。。。"</span>);</span><br><span class="line">        Object invoke = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//在真实的对象执行之后我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after invoke。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代理类的调用处理程序的invoke方法中的第一个参数proxy好像我们从来没有用过…</p>
<ul>
<li><strong>接下来我们看下客户端类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要代理的真实对象</span></span><br><span class="line">        People people = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">//代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中，最终代理对象的调用处理程序会调用真实对象的方法</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> WorkHandler(people);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数</span></span><br><span class="line"><span class="comment">         * 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口，这样代理对象就能像真实对象一样调用接口中的所有方法</span></span><br><span class="line"><span class="comment">         * 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        People proxy = (People)Proxy.newProxyInstance(handler.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);</span><br><span class="line">        <span class="comment">//System.out.println(proxy.toString());</span></span><br><span class="line">        System.out.println(proxy.work());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before invoke。。。</span><br><span class="line">老师教书育人...</span><br><span class="line">after invoke。。。</span><br><span class="line">教书1234</span><br></pre></td></tr></table></figure>

<p>​    通过上面的讲解和示例动态代理的原理及使用方法，在Spring中的两大核心IOC和AOP中的<strong>AOP(面向切面编程)的思想就是动态代理</strong>，<strong>在代理类的前面和后面加上不同的切面组成面向切面编程。</strong></p>
<p>上面我们只讲解了Proxy中的newProxyInstance（生成代理类的方法），但是它还有其它的几个方法，我们下面就介绍一下：</p>
<ul>
<li>getInvocationHandler：返回指定代理实例的调用处理程序</li>
<li>getProxyClass：给定类加载器和接口数组的代理类的java.lang.Class对象。</li>
<li>isProxyClass：当且仅当使用getProxyClass方法或newProxyInstance方法将指定的类动态生成为代理类时，才返回true。</li>
<li>newProxyInstance：返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/14/Redis%E8%AE%BE%E7%BD%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/14/Redis%E8%AE%BE%E7%BD%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F/" itemprop="url">Redis设置序列化方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-14T00:18:02+08:00">
                2020-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tags-Redis"><a href="#tags-Redis" class="headerlink" title="tags:Redis"></a>tags:Redis</h2><h2 id="Redis设置序列化方式"><a href="#Redis设置序列化方式" class="headerlink" title="Redis设置序列化方式:"></a>Redis设置序列化方式:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改默认的redisTemplate的持久化方式;</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object,Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/11/%E7%A7%92%E6%9D%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/11/%E7%A7%92%E6%9D%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" itemprop="url">秒杀开发笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-11T14:33:57+08:00">
                2020-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="秒杀开发笔记"><a href="#秒杀开发笔记" class="headerlink" title="秒杀开发笔记"></a>秒杀开发笔记</h2><h4 id="1-mapper-xml声明："><a href="#1-mapper-xml声明：" class="headerlink" title="1. mapper.xml声明："></a>1. mapper.xml声明：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-分层编写后端和前端页面：-view-gt-controller-gt-service-gt-dao"><a href="#2-分层编写后端和前端页面：-view-gt-controller-gt-service-gt-dao" class="headerlink" title="2. 分层编写后端和前端页面： view -&gt; controller -&gt; service -&gt; dao"></a>2. 分层编写后端和前端页面： view -&gt; controller -&gt; service -&gt; dao</h4><h4 id="3-压力测试：Jmeter"><a href="#3-压力测试：Jmeter" class="headerlink" title="3. 压力测试：Jmeter"></a>3. 压力测试：Jmeter</h4><p>启动命令：sh jmeter</p>
<p><img src="https://i.loli.net/2020/08/11/vBLh8yTw6gGJzqH.png" alt="image-20200811231556871"></p>
<p>模拟100用户、每个用户进行100次访问；</p>
<p>未使用redis缓存时：</p>
<p><img src="https://i.loli.net/2020/08/11/M8bmnruvPWTaezs.png" alt="image-20200811232126997"></p>
<ul>
<li><p><strong>Throughput</strong> <strong>:吞吐量：每秒489次请求</strong></p>
</li>
<li><p>Average/Min/Max 响应时间：192/s</p>
</li>
</ul>
<h3 id="高并发问题分析："><a href="#高并发问题分析：" class="headerlink" title="高并发问题分析："></a>高并发问题分析：</h3><p>​        在电商应用中,90%数据处理是用于<strong>读取</strong>数据,在海量数据的情况下,<strong>数据库</strong>最有可能成为<strong>高并发的瓶颈</strong>。因此<strong>提高数据库效率</strong>戓者<strong>降低数据库交互</strong>就是我们高并发首先要考虑的向题。</p>
<p>​        电商应用中,很大ー部分数据是在一段时间内稳定不变的, 其中很大ー部分数据是一段时间內稳定不变的,例如”商 信息”、””会员信息“、“网站基本信息”等；对于稳定数据,常用两种方式进行高并发处理：</p>
<ul>
<li>利用<strong>缓存</strong>( Redis、 Ehcache、 Memcached..) </li>
<li>利用<strong>静态化技术</strong>(staticize)转化为Html</li>
</ul>
<h4 id="4-静态数据优化：Redis缓存"><a href="#4-静态数据优化：Redis缓存" class="headerlink" title="4. 静态数据优化：Redis缓存"></a>4. 静态数据优化：Redis缓存</h4><p><strong>Redis在Springboot中的使用：</strong></p>
<p><strong>4.1 在主程序中开启声明式缓存注解支持</strong></p>
<p><img src="https://i.loli.net/2020/08/12/tdoGh3carImNRYv.png" alt="image-20200812000958909"></p>
<p><strong>4.2 对service层中的方法,利用@Cacheable注解开启缓存</strong></p>
<p><img src="https://i.loli.net/2020/08/12/AutzQpOKCnRIyJj.png" alt="image-20200812001021759"></p>
<p><strong>4.3 在yml中配置Redis信息：</strong></p>
<p><img src="https://i.loli.net/2020/08/12/N4ksY7B95TtE6Dj.png" alt="image-20200812001736099"></p>
<p><strong>4.4 使用redis后的JMeter吞吐量:</strong></p>
<p><img src="https://i.loli.net/2020/08/12/pLEWIlcMh4FujmO.png" alt="image-20200812005356116"></p>
<h4 id="5-页面静态化技术：-以空间换时间"><a href="#5-页面静态化技术：-以空间换时间" class="headerlink" title="5. 页面静态化技术：[以空间换时间]"></a>5. 页面静态化技术：[以空间换时间]</h4><p>​        页面静态化是指将动态页面(jsp/ freemarker,…)变成html静态页面。<strong>动态页面便于管理</strong>,但是访问网页时还需要程序先处理一遍,所以导致访问速度相对较慢。而<strong>静态页面访问速度快</strong>,却又不便于管理。<strong>静态化可以将两种页面的好处集中到一起</strong>。</p>
<p><img src="https://i.loli.net/2020/08/12/Y3BevfmSyuWcph5.png" alt="image-20200812010528716"></p>
<p>动态生成模板对象：</p>
<p><img src="https://i.loli.net/2020/08/12/V4z5U6iB72oQCAJ.png" alt="image-20200812112335667"></p>
<p>注：可以使用大循环直接对所有商品页面进行静态化即可；</p>
<h4 id="Nginx-反向代理服务器"><a href="#Nginx-反向代理服务器" class="headerlink" title="Nginx(反向代理服务器)"></a>Nginx(反向代理服务器)</h4><p>​        Nginx是一款轻量级的<strong>Web服务器/反向代理服务器</strong>, 其特点是<strong>占有内存少,并发能力强</strong>,事实上 nginx的并发能力确实在同类型的网页服务器中表现较好。</p>
<p>安装：brew install nginx</p>
<p>启动：brew services start nginx</p>
<p>路径：/usr/local/etc/nginx/nginx.conf</p>
<p>配置：在39行设置需要映射的根目录</p>
<p><img src="https://i.loli.net/2020/08/12/jgrJukMKb3YQNxf.png" alt="image-20200812131929792"></p>
<p><strong>使用nginx+静态化页面的并发表现：</strong></p>
<p><img src="https://i.loli.net/2020/08/12/dor42AWTXg6Sz93.png" alt="image-20200812133244195"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="静态化后的额外处理："><a href="#静态化后的额外处理：" class="headerlink" title="静态化后的额外处理："></a>静态化后的额外处理：</h4><p><strong>5.1 自动计划任务静态化</strong></p>
<p>使用Springboot的计划任务自动生成静态化页面：        </p>
<p><img src="https://i.loli.net/2020/08/12/7hxvEYtidUk8PQG.png" alt="image-20200812133838882"></p>
<p>找到数据库中上次修改不超过5分钟的数据：</p>
<p><img src="https://i.loli.net/2020/08/12/vypADPTGR1bhqeZ.png" alt="image-20200812135715368"></p>
<p>制定间隔5分钟的计划任务：</p>
<p><img src="https://i.loli.net/2020/08/12/egyAh9nvZfuHIJR.png" alt="image-20200812140403359"></p>
<p><strong>5.2 动静态数据分离：</strong></p>
<p>​    页面静态化执行效率固然高,但往往在页面中也存在动态数据。例如“评论”的内容就一直在不断变化肯定不能对其静态化处理。<strong>遇到这种动态数据需要在静态页面中使用AJAX动态加载后端产生的数据</strong>。</p>
<p>​    <img src="https://i.loli.net/2020/08/12/FRUkviKuDQEgtqN.png" alt="image-20200812141917901"></p>
<ul>
<li>使用ajax 加载动态的评论内容，写在goods.ftlh中：</li>
</ul>
<p><img src="https://i.loli.net/2020/08/12/UFaR3uqochsnTbm.png" alt="image-20200812232744872"></p>
<p>再重新生成全部的nginx静态化页面；</p>
<p>注意：此时，从nginx服务器访问网页，还不能找到对应的评论内容:</p>
<p><img src="https://i.loli.net/2020/08/12/5EvgojeKDYPzJ1U.png" alt="image-20200812234200597"></p>
<p><strong>因此需要配置Nginx代理</strong>：</p>
<p><img src="https://i.loli.net/2020/08/12/GK3D965RzEtbpaC.png" alt="image-20200812235453829"></p>
<p>​        通过此配置可以将 nginx的 /evaluate/页面代理到tomcat服务器的<a href="http://locathost:8080/evaluate" target="_blank" rel="noopener">http://locathost:8080/evaluate</a>; 注意要保持开启tomcat服务器，否则无法成功代理。</p>
<p><strong>总结动静分离的效果：</strong>访问静态化的页面时，如果需要访问动态数据：可以通过配置Nginx代理，将某页面代理到tomcat服务器，实现获取动态数据。</p>
<h4 id="6-秒杀问题分析："><a href="#6-秒杀问题分析：" class="headerlink" title="6. 秒杀问题分析："></a>6. 秒杀问题分析：</h4><p>​        秒杀我们日常开发中最常见的高并发场景。<strong>秒杀的特点</strong>：1）瞬超高访问量;  2)商品总量有限,先到先得;  3)有明确的开始、结束时间。</p>
<p>秒杀活动常见<strong>两个挑战</strong>:</p>
<ul>
<li><strong>高并发:</strong> 基本主流电商的秒杀QPS峰值都在100万+。</li>
<li><strong>避免超卖:</strong> 如何避免购买商品人数不超过商品数量上限,这是要面临的难题。</li>
</ul>
<img src="https://i.loli.net/2020/08/13/JBqLMRbHmCD6SKr.png" alt="image-20200813141732943" style="zoom:50%;" />

<img src="https://i.loli.net/2020/08/13/TxRobN2tv5E1KYM.png" alt="image-20200813141751633 " style="zoom:50%;" />

<p><strong>商品库存count的改变未保证对其他线程的可见性，因此发生超卖问题。</strong></p>
<p>解决方法：有多种方案来解决这个问题，我们主要看3种方案：</p>
<ul>
<li><p>悲观锁：影响性能；</p>
</li>
<li><p>乐观锁：高并发下失败率高，可引入重入机制在失败后重复尝试；</p>
</li>
<li><p><strong>Redis+ Lua</strong></p>
</li>
<li><h4 id="使用Redis预减库存-gt-解决超卖问题："><a href="#使用Redis预减库存-gt-解决超卖问题：" class="headerlink" title="使用Redis预减库存-&gt; 解决超卖问题："></a>使用Redis预减库存-&gt; 解决超卖问题：</h4></li>
</ul>
<p><strong>为什么选择 Redis</strong>：</p>
<ul>
<li>单线程模型</li>
<li>内存存储,高达10WQPS </li>
<li>天生分布式支持</li>
</ul>
<img src="https://i.loli.net/2020/08/13/Na9RSKfYqx7lkQg.png" alt="image-20200813215318480 " style="zoom:50%;" />



<h4 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h4><p><strong>6.1 编写mapper 数据库操作</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//查询出符合秒杀时间的商品：</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.geekouc.babytunseckill.dao.PromotionSecKillDAO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUnstartSecKill"</span> <span class="attr">resultType</span>=<span class="string">"com.geekouc.babytunseckill.entity.PromotionSecKill"</span>&gt;</span></span><br><span class="line">        select * from t_promotion_seckill </span><br><span class="line">      	where now() BETWEEN start_time AND end_time and status = 0</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">//更新秒杀状态：</span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"com.geekouc.babytunseckill.entity.PromotionSecKill"</span>&gt;</span></span><br><span class="line">        update t_promotion_seckill</span><br><span class="line">        set goods_id = #&#123;goodsId&#125;,ps_count = #&#123;psCount&#125;,</span><br><span class="line">  					start_time = #&#123;startTime&#125;, end_time = #&#123;endTime&#125;,</span><br><span class="line">            status = #&#123;status&#125;, current_price = #&#123;currentPrice&#125; </span><br><span class="line">  			where ps_id = #&#123;psId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>6.2 秒杀调度任务</strong>：每隔5秒检查符合秒杀时间的商品，使其进入秒杀状态,并将其放入Redis的List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PromotionSecKillDAO promotionSecKillDAO;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">//RedisTemplate是Spring封装的Redis操作类,提供了一系列操作redis的模板方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSecKill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PromotionSecKill&gt; list = promotionSecKillDAO.findUnstartSecKill();</span><br><span class="line">        <span class="keyword">for</span> (PromotionSecKill ps : list) &#123;</span><br><span class="line">          <span class="comment">//删除以前重复的活动任务缓存</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"seckill:count:"</span> + ps.getPsId());</span><br><span class="line">            System.out.println(ps.getPsId() + <span class="string">"秒杀活动已启动 !"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps.getPsCount(); i++) &#123;</span><br><span class="line">              <span class="comment">//有几个库存商品,则初始化几个list对象;list中先存入商品ID;</span></span><br><span class="line">              redisTemplate.opsForList().rightPush(<span class="string">"seckill:count:"</span> + ps.getPsId(),ps.getGoodsId());</span><br><span class="line">            &#125;</span><br><span class="line">            ps.setStatus(<span class="number">1</span>);</span><br><span class="line">            promotionSecKillDAO.update(ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.3 使用Redis实现库存预减</strong>：如果能从秒杀商品队列中获取有效的goodsId,就将psId和对应的userId放入Redis的set中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionSecKillService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PromotionSecKillDAO promotionSecKillDAO;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSecKill</span><span class="params">(Long psId, String userid, Integer num)</span> <span class="keyword">throws</span> SecKillException </span>&#123;</span><br><span class="line">    <span class="comment">//如果能从秒杀商品队列中获取有效的goodsId,就将psId和对应的userId放入Redis的set中;</span></span><br><span class="line">        PromotionSecKill ps = promotionSecKillDAO.findById(psId);</span><br><span class="line">        <span class="keyword">if</span> (ps == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//秒杀活动不存在:</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"该秒杀活动不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ps.getStatus() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"该秒杀活动还未开始!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ps.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"该秒杀活动已结束!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer goodsId = (Integer) redisTemplate.opsForList().leftPop(<span class="string">"seckill:count:"</span> + ps.getPsId());</span><br><span class="line">        <span class="keyword">if</span> (goodsId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先判断用户id的set集合中是否已经存在此id,若已存在则不允许再次抢购</span></span><br><span class="line">            <span class="keyword">boolean</span> isExisted = redisTemplate.opsForSet().isMember(<span class="string">"seckill:users:"</span> + ps.getPsId(), userid);</span><br><span class="line">            <span class="keyword">if</span> (!isExisted) &#123;</span><br><span class="line">                System.out.println(<span class="string">"恭喜"</span> + userid + <span class="string">"抢到商品了,快去下单吧!"</span>);</span><br><span class="line">                redisTemplate.opsForSet().add(<span class="string">"seckill:users:"</span> + ps.getPsId(), userid);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若该用户已抢购过，抛出自定义异常，并再将此商品加回队列的尾部；</span></span><br><span class="line">                redisTemplate.opsForList().rightPush(<span class="string">"seckill:count:"</span> + ps.getPsId(),ps.getGoodsId());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"抱歉,您已经参加过此活动,请勿重复抢购!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecKillException(<span class="string">"抱歉,该商品已被抢光,下次再来吧!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.4 Controller层</strong>：控制前端页面访问相应页面时调用秒杀方法，并返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    PromotionSecKillService promotionSecKillService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/seckill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">processSecKill</span><span class="params">(Long psid, String userid)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            promotionSecKillService.processSecKill(psid, userid, <span class="number">1</span>);</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"0"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, <span class="string">"success"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecKillException e) &#123;</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"500"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.5</strong> 设置前端seckill.html的抢购按钮入口，告诉用户抢购结果：</p>
<p><img src="https://i.loli.net/2020/08/14/1PCdutoH9sNxJDK.png" alt="image-20200814175009551"></p>
<p><strong>6.6</strong> 秒杀活动结束后：</p>
<p>将此秒杀任务状态设为已过期,并更新此状态,并清除redis中已过秒杀时间的商品：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endSecKill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PromotionSecKill&gt; psList = promotionSecKillDAO.findExpireSecKill();</span><br><span class="line">        <span class="keyword">for</span> (PromotionSecKill ps : psList) &#123;</span><br><span class="line">            System.out.println(ps.getPsId()+<span class="string">"秒杀活动已结束!"</span>);</span><br><span class="line">            <span class="comment">//秒杀结束后,将此秒杀任务状态设为已过期,并更新此状态</span></span><br><span class="line">            ps.setStatus(<span class="number">2</span>);</span><br><span class="line">            promotionSecKillDAO.update(ps);</span><br><span class="line">            <span class="comment">//删除redis中已过秒杀时间的商品;</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"seckill:count"</span> + ps.getPsId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-使用RabbitMQ：削峰、限流"><a href="#7-使用RabbitMQ：削峰、限流" class="headerlink" title="7. 使用RabbitMQ：削峰、限流"></a>7. 使用RabbitMQ：削峰、限流</h4><img src="https://i.loli.net/2020/08/15/tskMaEXieUHcpBD.png" alt="image-20200815003046510" style="zoom:50%;" />





<img src="https://i.loli.net/2020/08/15/M5pc3rfOYlAHmX4.png" alt="image-20200815003054692 " style="zoom:50%;" />

<img src="https://i.loli.net/2020/08/15/PyB7XD2A4kaS3wJ.png" alt="image-20200815140119283 " style="zoom:50%;" />

<p>7.0 配置好RabbitMQ的环境，创建一个Exchange和一个队列；</p>
<p>7.1 编写Service <strong>向MQ队列发送订单号（速度快）</strong>，并在Controller层调用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendOrderToQueue</span><span class="params">(String userid)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备向队列发送信息..."</span>);</span><br><span class="line">        <span class="comment">//订单基本信息;</span></span><br><span class="line">        HashMap&lt;String,String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">"userid"</span>,userid);</span><br><span class="line">        String orderNo = UUID.randomUUID().toString();</span><br><span class="line">        data.put(<span class="string">"orderNo"</span>,orderNo);</span><br><span class="line">        <span class="comment">//可附加额外的订单信息,如电话 地址等;</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"exchange-order"</span>,<span class="keyword">null</span>,data);</span><br><span class="line">        <span class="keyword">return</span> orderNo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/seckill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">processSecKill</span><span class="params">(Long psid, String userid)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            promotionSecKillService.processSecKill(psid, userid, <span class="number">1</span>);</span><br><span class="line">            String orderNo = promotionSecKillService.sendOrderToQueue(userid);</span><br><span class="line">            HashMap&lt;String,String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            data.put(<span class="string">"orderNo"</span>,orderNo); <span class="comment">//生成订单编号</span></span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"0"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, <span class="string">"success"</span>);</span><br><span class="line">            result.put(<span class="string">"data"</span>,data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecKillException e) &#123;</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"500"</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7.2 同时，将<strong>生成的订单号利用ajax回调给前端（速度快）</strong>：</p>
<img src="https://i.loli.net/2020/08/15/qsf5XM6z1ovdJKN.png" alt="image-20200815114423021 " style="zoom:50%;" />

<p>7.3 <strong>配置Rabbit消费者信息</strong>，并新建一个消费者类：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">listener:</span></span><br><span class="line">    <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#定义消费者最多同时处理10个消息</span></span><br><span class="line">      <span class="attr">prefetch:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment">#消息手动确认</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p>7.4 @RabbitHandler注解：<strong>自动从RabbitMQ队列中获取订单号，并实例化一个订单写入数据库中（速度慢）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderDAO orderDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(    <span class="comment">//绑定创建好的rabbitmq交换机和队列</span></span><br><span class="line">            bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">                  value = <span class="meta">@Queue</span>(value = <span class="string">"queue-order"</span>),</span><br><span class="line">                  exchange = <span class="meta">@Exchange</span>(value = <span class="string">"exchange-order"</span>,type = <span class="string">"fanout"</span>)</span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@RabbitHandler</span>  <span class="comment">//消费者获取订单数据,插入到数据库中;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@Payload Map&lt;String,Object&gt; data, Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                              @Headers  Map&lt;String,Object&gt; headers)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========获取到订单数据"</span>+data+<span class="string">"========"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//sleep 500ms,模拟对接支付、物流系统、日志登记...</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Order order = <span class="keyword">new</span> Order();</span><br><span class="line">            order.setOrderNo(data.get(<span class="string">"orderNo"</span>).toString());</span><br><span class="line">            order.setOrderStatus(<span class="number">0</span>);</span><br><span class="line">            order.setUserid(data.get(<span class="string">"userid"</span>).toString());</span><br><span class="line">            order.setRecvName(<span class="string">"xxx"</span>);</span><br><span class="line">            order.setRecvAddress(<span class="string">"xxx"</span>);</span><br><span class="line">            order.setRecvMobile(<span class="string">"138********"</span>);</span><br><span class="line">            order.setAmount(<span class="number">19.8f</span>);</span><br><span class="line">            order.setPostage(<span class="number">0f</span>);</span><br><span class="line">            order.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            orderDAO.insert(order);</span><br><span class="line">            Long tag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">            channel.basicAck(tag,<span class="keyword">false</span>);<span class="comment">//消息确认,false:只进行单个接收 不进行批量接收</span></span><br><span class="line">            System.out.println(data.get(<span class="string">"orderNo"</span>+<span class="string">"订单已创建"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.5 由于生产者和消费者是异步的关系，因此创建一个”正在创建订单,请稍后…”的页面，作为过渡：</p>
<img src="https://i.loli.net/2020/08/15/kTVd79Kz4Pyhmnr.png" alt="image-20200815145349034 " style="zoom:50%;" />

<p>同时，<strong>检查订单号是否已经在数据库中成功生成</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查订单号是否已经在数据库中成功生成</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/checkorder"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">checkOrder</span><span class="params">(String orderNo)</span></span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    Order order = promotionSecKillService.checkOrder(orderNo);</span><br><span class="line">    <span class="keyword">if</span>(order != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//代表订单已在数据库中创建好了</span></span><br><span class="line">        mav.addObject(<span class="string">"order"</span>,order);</span><br><span class="line">        mav.setViewName(<span class="string">"/order"</span>);</span><br><span class="line">        <span class="comment">//跳转到order页面,显示订单信息;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        mav.addObject(<span class="string">"orderNo"</span>,orderNo);</span><br><span class="line">        mav.setViewName(<span class="string">"/waiting"</span>);</span><br><span class="line">        <span class="comment">//跳转到等待页面...在等待页面等待三秒后再次尝试检查订单号...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-Nginx-负载均衡"><a href="#8-Nginx-负载均衡" class="headerlink" title="8. Nginx 负载均衡"></a>8. Nginx 负载均衡</h4><img src="https://i.loli.net/2020/08/15/ovnwH7kT5FK3g1P.png" alt="image-20200815155440698 " style="zoom:50%;" />

<p>Nginx<strong>六种负载均衡策略</strong>：</p>
<ul>
<li><strong>Default - 轮询策略</strong> </li>
<li><strong>Least connected - 最少连接策略</strong></li>
<li><strong>Weighted - 权重策略</strong></li>
<li><strong>IP Hash - IP绑定策略</strong> ：高并发下不推荐使用，因为会使负载不均衡</li>
<li>fair-按响应时间(第三方) </li>
<li>url hash-url分配策略(第三方)</li>
</ul>
<p><strong>8.1 使用Nginx代理后端服务器</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#后端服务器池</span><br><span class="line">upstream babytun &#123;</span><br><span class="line">	#least_conn; #最少连接策略</span><br><span class="line">	#ip_hash;	#ip_hash策略</span><br><span class="line"></span><br><span class="line">	server 192.168.1.3:8001 weight&#x3D;5; #按照权重分配</span><br><span class="line">	server 192.168.1.3:8002 weight&#x3D;2;</span><br><span class="line">	server 192.168.1.3:8003 weight&#x3D;1;</span><br><span class="line">	server 192.168.1.3:8004 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">		#nginx通过80端口提供服务</span><br><span class="line">    listen       80;  </span><br><span class="line">    #使用babytun服务器池进行后端处理</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">    	proxy_pass http:&#x2F;&#x2F;babytun;</span><br><span class="line">    	proxy_set_header Host $host;</span><br><span class="line">    	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        配置完成后，只需访问192.168.1.3/goods?gid=1234 即可访问我们的页面，nginx默认按照轮询策略在4台server之间切换服务器。</p>
<p><strong>8.2 Nginx分布式Session同步问题：</strong></p>
<p>​        例如使用Nginx负载均衡时,用户登录后,再刷新页面可能会代理到另一台server,而此台server没有之前的session,从而导致丢失登录状态。</p>
<p><strong>解决办法</strong>：<strong>将 Session转存到 Redis中实现 Session 共享访问</strong>:</p>
<p><img src="https://i.loli.net/2020/08/15/vSYuaK24FeN63yi.png" alt="image-20200815215155079 "></p>
<ul>
<li>pom中引入Spring-Session依赖以及Redis依赖</li>
<li>主程序启用@EnableRedisHttpSession即可；</li>
</ul>
<p><strong>Spring-Session将自动监听Session，并将其保存到Redis中</strong>！</p>
<p>​        这样，用户登录上去之后，之后无论是再代理到哪台服务器都会一直拥有这个Session,从而保持登录状态。</p>
<h4 id="9-Nginx缓存静态资源降低Tomcat压力："><a href="#9-Nginx缓存静态资源降低Tomcat压力：" class="headerlink" title="9. Nginx缓存静态资源降低Tomcat压力："></a>9. Nginx缓存静态资源降低Tomcat压力：</h4><p><strong>9.1 图片、样式等静态资源</strong>不再经过Tomcat服务器，直接由Nginx服务器指向指定文件夹：</p>
<img src="https://i.loli.net/2020/08/16/7wy9ZbANBcmxMpz.png" alt="image-20200816002658224 " style="zoom:50%;" />

<p>在/usr/local/etc/nginx/nginx.conf中修改配置即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#临时文件夹</span><br><span class="line">    proxy_temp_path &#x2F;Users&#x2F;tianjirong&#x2F;Documents&#x2F;babytun-lb&#x2F;nginx-temp;</span><br><span class="line">    #设置缓存目录;</span><br><span class="line">    #levels代表采用1:2,即采用两级目录的形式保存静态缓存文件，同时文件名进行了MD5编码;</span><br><span class="line">    #keys_zone 定义缓存名称 以及 内存大小使用100M交换空间;</span><br><span class="line">    #如果某个缓存文件超过7天未使用,则删除之;</span><br><span class="line">    #文件夹最大不超过20g,超过后自动删除访问频率最低的缓存文件;</span><br><span class="line">    proxy_cache_path &#x2F;Users&#x2F;tianjirong&#x2F;Documents&#x2F;babytun-lb&#x2F;nginx-cache levels&#x3D;1:2 keys_zone&#x3D;babytun-cache:100m inactive&#x3D;7d max_size&#x3D;20g;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	#nginx通过80端口提供服务</span><br><span class="line">    listen       80;  </span><br><span class="line"></span><br><span class="line">    #静态资源缓存,利用正则表达式匹配url,匹配成功的则执行内部逻辑,~*表示不区分大小写:</span><br><span class="line">    location ~* \.(gif|jpg|css|png|js|woff|html)(.*)&#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;babytun;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_cache babytun-cache;</span><br><span class="line">        #如果资源相应状态码为200-&gt;成功; 302-&gt;暂时性重定向时,资源缓存文件有效期1天;</span><br><span class="line">        proxy_cache_valid 200 302 24h;</span><br><span class="line">        proxy_cache_valid 301 24h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意：当需要缓存<strong>.html</strong>的页面时，需要保证该页面是不经常变动的，否则不应该缓存它。</p>
<p><strong>9.2 Nginx使用Gzip资源压缩：节省带宽</strong>：</p>
<ul>
<li>利用浏览器支持的Gzip压缩, <strong>nginx打包压缩并传输 css、js等静态资源</strong>,可将带宽压力降低30%~70%</li>
</ul>
<p><img src="https://i.loli.net/2020/08/16/5TFjhuVRGq314zd.png" alt="image-20200816132844932"></p>
<p>在/usr/local/etc/nginx/nginx.conf中开启Gzip即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#开启nginx Gzip压缩</span><br><span class="line">gzip  on;</span><br><span class="line">#超过1K的文件才压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line">#压缩哪些类型:对文本类型压缩效果很好 对图片效果不好</span><br><span class="line">gzip_types text&#x2F;plain application&#x2F;javascript text&#x2F;css application&#x2F;x-javascript;</span><br><span class="line">#当使用低版本IE浏览器时禁用压缩</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">#压缩使用的缓存,每个内存也为4K,申请32倍;一般这样写就可以</span><br><span class="line">gzip_buffers 32 4k;</span><br><span class="line">#最重要: 设置压缩级别: 1-9 越大压缩比越高,但浪费CPU资源,建议1-4即可</span><br><span class="line">gzip_comp_level 1;</span><br></pre></td></tr></table></figure>

<p><strong>9.3 使用CDN：解决带宽瓶颈、加速访问速度</strong></p>
<p>​        可将整个layui文件夹上传到CDN中,这样传输这些资源的时候,流量就不会走本地服务器,而是直接走CDN的服务器,实现解决带宽瓶颈和加速访问速度！</p>
<p><strong>使用方法</strong>：</p>
<ul>
<li>开通阿里云等<strong>OSS</strong>服务,向OSS中上传我们的资源</li>
<li>开通阿里云<strong>CDN</strong>服务,将OSS中的资源分发到各个CDN服务器</li>
<li>将自己的<strong>域名绑定映射</strong>到CDN服务器</li>
<li>在前端页面中将所用资源的本地路径改为自己域名中的<strong>远程路径</strong>即可</li>
</ul>
<h4 id="10-流量防刷与反爬虫："><a href="#10-流量防刷与反爬虫：" class="headerlink" title="10. 流量防刷与反爬虫："></a>10. 流量防刷与反爬虫：</h4><p><strong>实现思路</strong>：</p>
<ul>
<li><p>Redist提供了TTL有效期特性(<strong>设置超时时间</strong>)</p>
</li>
<li><p>对于每一个用户,<strong>在 Redisi记录访向次数</strong>：</p>
<p>例如​ key:188.38.12.33  value:39 超时时间:60s</p>
</li>
<li><p><strong>用户每访问1次,对应计数器+1</strong>,超过上限(30)则停止服务</p>
</li>
<li><p>如计数器<strong>超过100则认为爬虫攻击</strong>,永久加入黑名单</p>
</li>
<li><p>1分钟后key销毁,重新开始计数</p>
</li>
</ul>
<p><strong>实现过程</strong>：</p>
<ol>
<li>编写SpringBoot的AOP拦截器,</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AOP拦截器功能:流量防刷</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntiRefreshInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">//RedisTemplate,用于筒化 Redis操作,在IOC容器中自动被初始化</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>); <span class="comment">//设置提示信息的字符集</span></span><br><span class="line">        String clientIp = request.getRemoteAddr();<span class="comment">//获取客户端IP</span></span><br><span class="line">        String userAgent = request.getHeader(<span class="string">"User-Agent"</span>);<span class="comment">//获取客户端浏览器信息</span></span><br><span class="line">        String client = <span class="string">"anti-refresh:"</span> + DigestUtils.md5Hex(clientIp + <span class="string">"_"</span> + userAgent);<span class="comment">//用MD5摘要来标识一个用户</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//若此IP在黑名单中,则直接返回false;</span></span><br><span class="line">        <span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">"anti-refresh:blackList"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(redisTemplate.opsForSet().isMember(<span class="string">"anti-refresh:blackList"</span>,client))&#123;</span><br><span class="line">                response.getWriter().println(<span class="string">"检测到您的IP访问异常,您已被加入黑名单!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer num = (Integer) redisTemplate.opsForValue().get(client);<span class="comment">//记录1分钟内的访问次数</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span>)&#123;<span class="comment">//第一次访问</span></span><br><span class="line">            redisTemplate.opsForValue().set(client,<span class="number">1</span>,<span class="number">60</span>, TimeUnit.SECONDS); <span class="comment">//放入redis,有效期60S</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">20</span> &amp;&amp; num &lt; <span class="number">40</span>)&#123;</span><br><span class="line">                response.getWriter().println(<span class="string">"请求过于频繁,请1分钟后重试!"</span>);</span><br><span class="line">                redisTemplate.opsForValue().increment(client,<span class="number">1</span>); <span class="comment">//每访问一次redis的值+1;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">40</span>)&#123;</span><br><span class="line">                redisTemplate.opsForSet().add(<span class="string">"anti-refresh:blackList"</span>,clientIp);</span><br><span class="line">                response.getWriter().println(<span class="string">"检测到您的IP访问异常,您已被加入黑名单!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"IP"</span>+clientIp+<span class="string">"访问异常,已被加入黑名单!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.opsForValue().increment(client,<span class="number">1</span>); <span class="comment">//每访问一次redis的值+1;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注入拦截器：写一个@Configuration类即可.可选择需要拦截的页面,如:”/goods”</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AntiRefreshInterceptor antiRefreshInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//注入拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(antiRefreshInterceptor).addPathPatterns(<span class="string">"/goods"</span>);<span class="comment">//作用的URL;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/%E7%A7%8B%E6%8B%9B%E5%BE%85%E6%8A%95%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/10/%E7%A7%8B%E6%8B%9B%E5%BE%85%E6%8A%95%E9%80%92/" itemprop="url">秋招待投递</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-10T22:42:42+08:00">
                2020-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="秋招待投递："><a href="#秋招待投递：" class="headerlink" title="秋招待投递："></a>秋招待投递：</h2><p>广汽丰田： <a href="https://gac-toyota.zhiye.com/CAMPUS" target="_blank" rel="noopener">https://gac-toyota.zhiye.com/CAMPUS</a></p>
<p>长虹： 长虹研究院 – Java工程师（成都）<a href="http://campus.51job.com/ch2021/" target="_blank" rel="noopener">http://campus.51job.com/ch2021/</a></p>
<p>小米：<a href="https://app.mokahr.com/campus_apply/xiaomi/24517#/job/109cb990-dd53-47b8-9846-90d3b2b1fcc1" target="_blank" rel="noopener">https://app.mokahr.com/campus_apply/xiaomi/24517#/job/109cb990-dd53-47b8-9846-90d3b2b1fcc1</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/08/Redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/08/Redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/" itemprop="url">Redis之事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-08T22:07:36+08:00">
                2020-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Redis之事务"><a href="#1-Redis之事务" class="headerlink" title="1. Redis之事务"></a>1. Redis之事务</h2><p><strong>Redis事务的概念：</strong></p>
<p>　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>　　总结：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　</p>
<p><strong>Redis事务没有隔离级别的概念：</strong></p>
<p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
<p><strong>Redis不保证原子性：</strong></p>
<p>　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<p><strong>Redis事务的三个阶段：</strong></p>
<ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<p><strong>Redis事务相关命令：</strong></p>
<p>　　watch key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</p>
<p>　　multi : 标记一个事务块的开始（ queued ）</p>
<p>　　exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</p>
<p>　　discard : 取消事务，放弃事务块中的所有命令</p>
<p>　　unwatch : 取消watch对所有key的监控</p>
<h2 id="事务的案例："><a href="#事务的案例：" class="headerlink" title="事务的案例："></a>事务的案例：</h2><p><img src="https://i.loli.net/2020/08/08/QgK91xnCWOUVBJX.png" alt="image-20200808220258106"></p>
<p><img src="https://i.loli.net/2020/08/08/eUFzTowvlXr89DQ.png" alt="image-20200808220315726"></p>
<p><img src="https://i.loli.net/2020/08/08/Hx8Q9wC6e5smhut.png" alt="image-20200808220323889"></p>
<p><img src="https://i.loli.net/2020/08/08/3tKf4p9G7dPnYEJ.png" alt="image-20200808220336464"></p>
<h2 id="使用watch乐观锁的案例"><a href="#使用watch乐观锁的案例" class="headerlink" title="使用watch乐观锁的案例"></a>使用watch乐观锁的案例</h2><p><img src="https://i.loli.net/2020/08/08/zCeULYA8B5FQmPp.png" alt="image-20200808220441009"></p>
<p><img src="https://i.loli.net/2020/08/08/rZD64lAjXRBHUF8.png" alt="image-20200808220646701"></p>
<p><strong>总结：</strong></p>
<p>​        watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/08/Redis%E4%B9%8BHyperLogLog%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/08/Redis%E4%B9%8BHyperLogLog%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" itemprop="url">Redis之HyperLogLog与布隆过滤器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-08T21:09:27+08:00">
                2020-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redis的HyperLogLog与布隆过滤器"><a href="#redis的HyperLogLog与布隆过滤器" class="headerlink" title="redis的HyperLogLog与布隆过滤器"></a>redis的HyperLogLog与布隆过滤器</h2><p>​        首先，HyperLogLog与布隆过滤器都是针对大数据统计存储应用场景下的知名算法。HyperLogLog是在大数据的情况下关于数据基数的空间复杂度优化实现，布隆过滤器是在大数据情况下关于检索一个元素是否在一个集合中的空间复杂度优化后的实现。在传统的数据量比较低的应用服务中，我们要实现数据基数和数据是否存在分析的功能，通常是简单的把所有数据存储下来，直接count一下就是基数了，而直接检索一个元素是否在一个集合中也很简单。</p>
<p>​        但随着数据量的急剧增大，传统的方式已经很难达到工程上的需求。过大的数据量无论是在存储还是在查询方面都存在巨大的挑战，无论我们是用位存储还是树结构存储等方式来优化，都没法达到大数据时代的要求或者是性价比太低。</p>
<p>​        于是HyperLogLog与布隆过滤器这两个算法就很好的派上了用场。他们的使用可以极大的节约存储空间，作为代价，则是牺牲了一个小概率的准确性，这可以很好的达到工程上的需求，对于那些要求准确度没那么高，但数据量巨大的需求是非常合适的。</p>
<p><strong>HyperLogLog原理</strong></p>
<p>​        最直白的解释是，给定一个集合 S，对集合中的每一个元素，我们做一个哈希，假设生成一个 16 位的比特串，从所有生成的比特串中挑选出前面连续 0 次数最多的比特串，假设为 0000000011010110，连续 0 的次数为 8，因此我们可以估计该集合 S 的基数为 2^9。当然单独用这样的单一估计偶然性较大，导致误差较大，因此在实际的 HyperLogLog 算法中，采取分桶平均原理了来消除误差。</p>
<p><strong>特点</strong>：实现<strong>牺牲了一定的准确度</strong>（在一些场景下是可以忽略的），但却实现了<strong>空间复杂度上的极大的压缩</strong>，可以说是性价比很高的。虽然基数不完全准确，但是可以符合，随着数量的递增，基数也是递增的。</p>
<p><strong>布隆过滤器原理</strong></p>
<p><img src="https://i.loli.net/2020/08/08/DkTrtSgCYmuWyqR.png" alt="image-20200808210404433"></p>
<p>​        <strong>布隆过滤器</strong>（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k，以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置为0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，<strong>这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1</strong>。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。<strong>如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中</strong>。注意：此处不能判断该元素是否一定存在集合中，可能<strong>存在一定的误判率</strong>。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p>
<p><strong>特点：巧妙的使用hash算法和bitmap位存储的方式，极大的节约了空间。</strong></p>
<p>​        由于主要用的是hash算法的特点，所有满足和hash算法相同的规则：当过滤器返回 true时（表示很有可能该值是存在的），有一定概率是误判的，即可能不存在；当过滤器返回false时（表示确定不存在），是可以完全相信的。</p>
<p>​        我们换个数据的角度来看规则：当数据添加到布隆过滤器中时，对该数据的查询一定会返回true；当数据没有插入过滤器时，对该数据的查询大部分情况返回false，但有小概率返回true，也就是误判。</p>
<p>　     我们知道它最终满足的规则和hash的规则是一致的，只是组合了多个hash，使用了bitmap来存储，大大优化了存储的空间和判断的效率。</p>
<p><strong>redis中的HyperLogLog</strong></p>
<p>在redis中对HyperLogLog 的支持早在2.8.9的时候就有了。它的操作非常简单</p>
<ul>
<li><a href="http://redisdoc.com/hyperloglog/pfadd.html" target="_blank" rel="noopener">PFADD</a> 给HyperLogLog添加值</li>
<li><a href="http://redisdoc.com/hyperloglog/pfcount.html" target="_blank" rel="noopener">PFCOUNT</a> 获取基数</li>
<li><a href="http://redisdoc.com/hyperloglog/pfmerge.html" target="_blank" rel="noopener">PFMERGE</a> 合并两个HyperLogLog数据（完美合并，分别添加和统一添加的结果是一致的）</li>
</ul>
<p><strong>redis中的布隆过滤器</strong></p>
<p>​        在redis中的布隆过滤器的支持是在redis4.0后支持插件的情况下，通过插件的方式实现的 ，redis的布隆过滤器插件地址：<a href="https://github.com/RedisLabsModules/rebloom" target="_blank" rel="noopener">https://github.com/RedisLabsModules/rebloom</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;size&#125;   </span><br><span class="line"><span class="comment">//创建一个布隆过滤器,key为redis存储键值，error_rate 为错误率</span></span><br><span class="line">BF.ADD &#123;key&#125; &#123;item&#125;  </span><br><span class="line"><span class="comment">//添加值到布隆过滤器中（当过滤器不存在的时候会，会以默认值自动创建一个，建议最好提前创建好）</span></span><br><span class="line">BF.EXISTS &#123;key&#125; &#123;item&#125;  </span><br><span class="line"><span class="comment">//判断值是否存在过滤器中: true（表示很可能存在） false （表示绝对不存在）</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/06/LeetCode%20%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/06/LeetCode%20%E5%9B%9E%E6%BA%AF%E6%B3%95/" itemprop="url">LeetCode 回溯法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-06T21:04:17+08:00">
                2020-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%B7%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="回溯法解题框架："><a href="#回溯法解题框架：" class="headerlink" title="回溯法解题框架："></a>回溯法解题框架：</h3><p><strong>回溯法有3种题型：</strong></p>
<ol>
<li><p>find a path to success;</p>
</li>
<li><p>find all path to success : </p>
<p>2.1 求解的个数；</p>
<p>2.2 求所有的解；【重点】</p>
</li>
<li><p>find the best path to success;</p>
</li>
</ol>
<p><strong>框架：</strong></p>
<p>result = [];</p>
<p>def backTracc(path,选择列表)：</p>
<p>​    if(满足剪枝条件): 剪枝，return；</p>
<p>​    if(满足结果条件)：result.add(path); return;</p>
<p>for 选择 in 选择列表：</p>
<p>​    做选择;</p>
<p>​    backTrace(路径，选择列表);  //进入下一层决策树；</p>
<p>​    撤销选择;</p>
<p>具体情况优化：</p>
<p>【1】当path为StringBulider时，可严格按照上述流程来写。当path为String时，由于String是final修饰的，因此可以省略撤销选择的过程，因为循环中的每次递归用的都是新的变量，与原变量无关，因此不需要对原变量进行撤销选择的操作。（缺点：每次递归都要建立一个新变量）</p>
<p>LeetCode17：电话号码的字母组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 电话号码的字母组合17 </span>&#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    HashMap&lt;Character, String&gt; map; <span class="comment">//用于映射数字和对应的字母</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;  <span class="comment">//特判</span></span><br><span class="line"></span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        map.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        map.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        map.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        map.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        map.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        map.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        map.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line"></span><br><span class="line">        backTrack(digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//digits:一串数字,如:234</span></span><br><span class="line">    <span class="comment">//index:第几位数字:如 2</span></span><br><span class="line">    <span class="comment">//letters:组成的字母:如 adg</span></span><br><span class="line">    <span class="comment">//index:需要递归的数字索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(String digits, <span class="keyword">int</span> index, StringBuilder letters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == index) &#123;   <span class="comment">//满足结束条件</span></span><br><span class="line">            res.add(letters + <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String alphas = map.get(digits.charAt(index));<span class="comment">//获取"abc"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">0</span>; i &lt; alphas.length(); ++i) &#123;</span><br><span class="line">            letters.append(alphas.charAt(i));       <span class="comment">//做选择:将当前字母添加到路径</span></span><br><span class="line">            backTrack(digits, index + <span class="number">1</span>, letters); <span class="comment">//进入下一层决策树</span></span><br><span class="line">            letters.deleteCharAt(letters.length() - <span class="number">1</span>);<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>LeetCode22：括号生成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        backTrace(n,<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> n,String path,<span class="keyword">int</span> numLeft,<span class="keyword">int</span> numRight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRight &gt; numLeft || numLeft &gt; n || numRight &gt; n)    <span class="keyword">return</span>;<span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(numLeft == n &amp;&amp; numRight == n)&#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrace(n,path+<span class="string">"("</span>,numLeft+<span class="number">1</span>,numRight);</span><br><span class="line">        backTrace(n,path+<span class="string">")"</span>,numLeft,numRight+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/%E5%9F%BA%E4%BA%8ESpringBoot+Mybatis+Thymeleaf%E7%9A%84%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/04/%E5%9F%BA%E4%BA%8ESpringBoot+Mybatis+Thymeleaf%E7%9A%84%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" itemprop="url">基于SpringBoot+Mybatis+Thymeleaf的员工信息管理系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-04T00:18:13+08:00">
                2020-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基于SpringBoot-Mybatis-Thymeleaf的员工信息管理系统"><a href="#基于SpringBoot-Mybatis-Thymeleaf的员工信息管理系统" class="headerlink" title="基于SpringBoot+Mybatis+Thymeleaf的员工信息管理系统"></a>基于SpringBoot+Mybatis+Thymeleaf的员工信息管理系统</h2><p>本项目是一个采用SpringBoot框架开发的轻量级后台管理系统，其主要逻辑与模块：</p>
<ul>
<li>系统模块架构：实体类包括用户信息类、部门信息类；Dao层使用xml文件编写SQL语句；Service层封装增删改查的方法；Controller层处理外部请求并返回页面。</li>
<li>登录验证和授权管理：使用SpringSecurity框架实现高效的拦截器功能，控制普通账户和管理员账户的页面访问权限和数据修改权限。</li>
<li>数据库连接池：配置Druid数据源，实时监控SQL执行信息。</li>
</ul>
<h3 id="涉及技术："><a href="#涉及技术：" class="headerlink" title="涉及技术："></a>涉及技术：</h3><ul>
<li><p>使用maven进行项目构建与管理</p>
</li>
<li><p>使用Springboot+Mybatis快速搭建系统</p>
</li>
<li><p>使用MySQL数据库管理信息</p>
</li>
<li><p>使用Thymeleaf模板引擎实现页面静态化</p>
</li>
<li><p>使用SpringSecurity实现认证与授权服务</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/10/%E7%94%A8%E4%BA%8E%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA%E7%9A%84%E5%8F%8CCNN%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/10/%E7%94%A8%E4%BA%8E%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA%E7%9A%84%E5%8F%8CCNN%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%AD%E7%BB%83/" itemprop="url">用于图像去噪的双CNN神经网络的设计与训练</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-10T13:51:07+08:00">
                2020-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用于图像去噪的双CNN神经网络的设计与训练"><a href="#用于图像去噪的双CNN神经网络的设计与训练" class="headerlink" title="用于图像去噪的双CNN神经网络的设计与训练"></a>用于图像去噪的双CNN神经网络的设计与训练</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    用于图像去噪的深卷积神经网络(CNNs)近年来引起了越来越多的研究兴趣。然而，普通网络不能恢复复杂任务的精细细节，例如真实的噪声图像。在本文中，我们提出了一种双重去噪网络(DudeNet)来恢复干净的图像。具体地，DudeNet由四个模块组成：特征提取块、增强块、压缩块和重构块。特征提取模块采用稀疏机制，通过两个子网络分别提取全局特征和局部特征。增强块收集并融合全局和局部特征，为后一种网络提供补充信息。压缩块细化提取的信息并压缩网络。最后，利用重建块重建去噪后的图像。DudeNet具有以下优点：</p>
<p>(1)具有解析机制的双重网络可以提取互补特征，增强去噪器的泛化能力。</p>
<p>(2)融合全局特征和局部特征可以提取显著特征，恢复复杂噪声图像的精细细节。</p>
<p>(3)采用小尺寸滤波器来降低去噪器的复杂度。大量的实验证明了DudeNet比现有最先进的去噪方法的优越性。</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>​    图像去噪是低级计算机视觉领域的一个长期存在的问题[1，2]。一般而言，它可用于通过退化模型y=x+v恢复高质量图像(也被视为潜在的干净图像)x，其中y表示受污染(有噪声)图像，v是标准差为σ的加性高斯白噪声。在贝叶斯推理观点中，先验知识对图像去噪有重要影响[3]。例如，加权核范数最小化(WNNM)[4]利用奇异值来导出不同的权重作为解。然后，小波NNM处理基于非局部自相似性的图像去噪。块匹配和3-D滤波(BM3D)方法[5]结合了3D数据和稀疏性，优先处理图像去噪问题。同时使用信号处理技术和现有技术有利于图像处理应用[6]。为了提高去噪的效率，开发了字典学习技术来抑制噪声[7]。</p>
<p>​    虽然基于先验的方法可以获得很好的去噪效果，但它们面临着参数手动设置和复杂的优化算法的挑战。针对这些问题，提出了多种判别学习方法来训练图像先验模型。例如，施密特等人提出了收缩场级联(CSF)模型[8]，利用展开的半二次优化算法进行图像恢复。Chen等人设计了可训练非线性反应扩散(TNRD)方法[9]来训练基于梯度下降推理的专家领域图像先验的去噪模型。虽然这些方法对图像去噪效果较好，但它们的应用受到所用先验的限制。此外，它们需要几个手动调整的参数才能获得最佳参数[10]。另外，上述方法只适用于一定的噪声水平，对盲去噪效果不佳。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image001.png)</p>
<p>​    最近提出的CNN在很大程度上改进了图像去噪[11]。张等人提出了去噪卷积神经网络(DnCNN)[10]，它使用残差学习(RL)和批处理重整化(BN)[12]来去除噪声。具体地说，DnCNN首先应用单个模型来处理多个应用，例如，图像去噪、超分辨率和去块。这些多用途方法的有效性取决于所使用的核心结构。如果它们的核心结构不能很好地恢复动态或复杂任务的清晰图像细节，例如真实世界中损坏的图像和盲噪声，这些方法可能不能很好地执行[13]。为了解决这些问题，我们提出了一种计算量较小的双重去噪网络(DudeNet)，如图1所示。DudeNet由四个部分组成：特征提取块(FEB)、增强块(EB)、压缩块(CB)和重构块(RB)。具体地说，具有稀疏机制的FEB首先从给定的噪声图像中提取全局和区域特征。然后，为了逐步增强残差信息，EB通过两阶段机制融合全局特征和局部特征，为后一网络提供补充信息。然后，对CB进行叠加，提取得到的残差图像，减少局部参数的个数。最后，RB从残差和噪声图像中重建出潜在的干净图像。</p>
<p><strong>拟议的DudeNet有几个优点：</strong></p>
<p>(1)采用稀疏机制的双网络可以提取不同的特征，提高去噪器处理复杂任务(如真实世界中的图像和盲噪声)的泛化能力。提出的双网络具有稀疏机制，可以提取不同的特征，提高去噪器处理复杂任务的能力。</p>
<p>(2)融合全局特征和局部特征可以获得显著的特征来恢复细节，可以合并双网络来处理复杂的去噪任务。</p>
<p>(3)采用小尺寸滤波器来降低去噪器的复杂度。</p>
<p>本文的其余部分组织如下:第二节综述了与我们提出的方法相关的几项工作。第三节详细阐述了拟议的DudeNet。第四节给出了所提出的DudeNet的综合实验结果，并进行了深入的分析。第五节得出结论。</p>
<h3 id="2-相关工作："><a href="#2-相关工作：" class="headerlink" title="2 相关工作："></a>2 相关工作：</h3><p><strong>A.  深度CNN在图像去噪中的应用：</strong></p>
<p>由于深层CNN的表达能力强、速度快，许多基于CNN的去噪方法已经成为低层视觉任务的热门方法[14]。张某等人提出了一种快速灵活的去噪网络以及基于噪声级图和含噪图像的FFDNet盲去噪方法[15]。为了更好地权衡效率和专门任务之间的关系，张等人提出了一种新的解决方案。提出了一种判别学习和基于模型优化相结合的图像复原CNN(IRCNN)[16]方法来预测干净的图像。为了便于培训，刘等人提出了一种深度多层小波CNN(MWCNN)[17]，它融合了Unet结构[18]和小波来提取频率特征，用于图像恢复任务。Tai等人的研究成果提出了一种由递归和门单元组成的深层次持久存储网络(又称MemNet)[19]来恢复高质量的图像，以挖掘更准确的信息。毛等人开发了一种更深的30层残差编解码器网络(RED30)[20]，由大量卷积和随后的转置卷积组成，以获得更清晰的图像。虽然有些方法在图像恢复方面取得了很好的效果，但它们都依赖于主体结构。当主要结构的细节恢复良好时，其性能是完美的。然而，对于多变或复杂的任务，如盲噪声和真实噪声图像，主要结构不能很好地恢复，这些方法效果不佳[13]。为了解决这个问题，潘等人[13]提出用双卷积神经网络提取互补特征来增强低水平视觉任务中恢复的细节。受此启发，我们使用双CNN来去除噪声，特别是变化的噪声图像(即现实应用中的受损图像和盲噪声)。</p>
<p><strong>B.  用于图像去噪的基于深度CNN的模块：</strong></p>
<p>由于端到端的连接架构，具有灵活插件的CNN被广泛用于许多任务，即图像[21]、视频[22]和文本应用[23]。具体地说，CNN中的模块或块用于低级计算机视觉，特别是图像超分辨率[24，25]和去噪[26]。基于模块的深度神经网络主要分为两类：提高性能、加快速度。对于第一个方面，学者们主要是融合获得的多个特征来增强CNN的表达能力。例如，深度提升框架(DBF)[27]使用特征提取、特征集成和重构块来抑制噪声。具体地说，特征集成块使用多个级联操作来融合特征。级联残差网络(CARN)[28]通过重复级联残差块实现图像超分辨率的集成特征。残差密集网络(RDN)[29]通过递归使用残差块来重复融合全局和局部特征，以提高图像的超分辨率性能。</p>
<p>对于第二个方面，压缩网络是提高网络速度的常用方法。例如，一种轻量级特征融合网络(LFFN)[30]被用来减小卷积核大小和压缩训练模型。自适应加权超分辨网络(AWSRN)[31]利用自适应加权多尺度(AWMS)模块对小尺度卷积进行裁剪。信息提取网络(IDN)[32]使用三个块(即，信息提取块、信息提取块、构造块)来提取所获得的特征。具体地说，信息精馏模块使用1×1的分组卷积和卷积核来降低网络参数和计算量。这些方法在图像超分辨率或去噪性能或效率上都取得了较好的效果。因此，本文提出了基于块的DudeNet来缩小去噪效率和去噪性能之间的差异，以达到去噪的目的。DudeNet的详细信息将在第三节中显示。</p>
<h3 id="3-所提方法"><a href="#3-所提方法" class="headerlink" title="3 所提方法:"></a>3 所提方法:</h3><p><strong>A 网络结构：</strong></p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png)</p>
<p>​    如图1所示，所提出的DudeNet由四个部分组成：特征提取块(FEB)、增强块(EB)、压缩块(CB)和重构块(RB)。FEB采用稀疏机制，既能提取不同的特征，又能降低网络的深度。EB通过将特征融合在两个子网络中来增强提取的特征，这对于被未知类型的噪声污染的图像特别有用，例如许多真实的被破坏的图像和盲噪声。CB对网络进行压缩，以降低计算成本。最后用RB重建干净的图像。</p>
<p>​    具体地，FEB包含两个子网络，分别是FEB-Net1和FEBnet2，其中FEBnet1包括稀疏机制。我们将DudeNet的输入表示为Y，输出表示为X。利用这两个16层子网络从输入的含噪图像中提取两个不同的特征映射。FEB CAN的过程表示为：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image003.png)</p>
<p>​    其中，Fi(Y)和FEBi分别表示第i个网络的特征提取函数和提取的特征。</p>
<p>​    EB包含两个部分：增强块1(EB1)和增强块2(EB2)。FEB的输出被送入EB1，EB1通过链式方式融合来自FEB的上述两个子网的两个不同的特征：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png)</p>
<p>​    其中E表示EB1和EB2的功能，OE1表示EB1的输出。</p>
<p>​    CB由三个压缩块(CB1)、压缩块2(CB2)和压缩块3(CB3)组成。请注意，CB1集成在FEBnet1中。放置在EB1和EB2之间的CB2用于细化提取的特征，如下所述：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image005.png)</p>
<p>​    其中C1分别表示CB1、CB2和CB3的功能。OCB2是CB2的输出。</p>
<p>在CB2之后，EB2用于获取如下公式的补充信息：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image006.png)</p>
<p>​    其中OE2代表EB2的输出。</p>
<p>​    然后，CB3进一步对EB2的输出进行如下处理：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image007.png)</p>
<p>​    其中OCB3表示CB3的输出。</p>
<p>​    最后，利用RB构造潜在的干净版本。使用以下残差运算从所获得的残差特征OCB3中提取输入Y：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png)</p>
<p>​    其中‘−’表示残差操作。</p>
<p> <strong>B．特征提取块(FEB)：</strong></p>
<p>​    FEB用于提取可靠的视觉特征。FEB由第一网络和第二网络组成。具体地说，第一个网络可以分为三个模块：Conv+BN+RELU、扩展Conv+BN+RELU和Conv。具体地说，在所提出的稀疏机制中，扩张卷积+BN+RELU依次执行扩张卷积[33]、批归一化[12]和校正线性单元[34]。Conv+BN+RELU在第1、3、4、6、7、8、10、11、13、14、15层起作用，扩张型Conv+BN+REU设计在第2、5、9、12层，Conv形成第16层。所有卷积层的滤波器大小均设置为3×3，2-16层的大小为64×3×3×64。第1层的大小为c×3×3×64，其中c是通道号，其中c=1和c=3分别表示输入的噪声图像是灰度图像和彩色图像。此外，层2-12包括FEBnet1中的稀疏机制。文献[35]表明，稀疏性可以放大少量大能点的效应。基于此，我们在FEB1的FEBnet1中提出了一种稀疏机制。具体地说，第2、5、9和12层通过一系列膨胀因子为2的膨胀卷积可以捕捉到丰富的上下文信息，即大能量点。FEBnet1的其他层进行普通卷积提取的特征比膨胀卷积层提取的特征相对较少，即小能量点。大能点和低能点的联合利用利用了稀疏性。因此，FEBnet1中的第2-12层称为稀疏机制。因此，FEBnet1的功能可以表示如下：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image009.png)</p>
<p>​    其中CBR1、S、CBR3和C分别代表Conv+BN+REU的功能，设计了稀疏机制，设计了3个Conv+BN+REU和1个3×3卷积。这被转换为F1(Y)=feb1通过(1)。</p>
<p>​    第二子网FEBnet2包含两个不同的模块：Conv+RELU和CB1。具体地说，Conv+REU指的是滤波器大小为3×3的卷积，然后是RELU。CB1通过1×1卷积层实现。第2-15层的尺寸均为64×3×3×64。第1层和第16层的尺寸分别设计为c×3×3×64和64×1×1×64，其中c为通道数。FEBnet2的程序可以制定如下：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image010.png)</p>
<p>​    其中CR15表示十五个Conv+REU的功能。</p>
<p><strong>C.  增强模块(EB)：</strong></p>
<p>​    EB使用两个部分来增强所设计网络的学习功能，适用于实际应用中的未知类型的噪声，如受损图像和盲噪声。拟议的EB在FEB和CB3之间工作，包括EB1和EB2两个部分。具体地说，EB1在FEB和CB2之间起作用。EB1由三部分组成：融合部分、BN部分和RELU部分。首先，融合部分通过串联操作集成来自不同网络(第一和第二网络)的两种不同类型的特征[36]。众所周知，在第一个网络中通过膨胀卷积获得的特征与在第二个网络中通过膨胀卷积获得的特征是不同的，这导致在EB1中获得的特征的分布有很大的不同。因此，使用BN来消除不良影响。最后，利用RELU将得到的线性特征转换为非线性特征。这一过程可以制定如下：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image011.png)</p>
<p>​    其中B是BN的函数，R表示激活函数RELU。EB2，介于CB2和CB3之间，将DudeNet的输入和CB2的输出连接起来，产生重要信息。这一过程可以用以下表达式表示：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image012.png)</p>
<p>​    其中OE2扮演CB3的角色。</p>
<p><strong>D.  压缩块(Cb)和重建块(Rb)：</strong></p>
<p>​    利用CB对提取出的特征进行更准确的提取，降低了计算量。它由CB1、CB2和CB3三部分组成。具体地说，尺寸为64×1×1×64的CB1被放置在Feb的FEBnet2的第16层中，尺寸为128×1×1×c的CB2被放置在EB1和EB2之间，尺寸为2c×1×1×c的CB3被放置在EB2和Rb之间，其中c是通道尺寸。此外，CB1、CB2和CB3由1×1卷积实现，这可以降低它们的维数并提高DudeNet的效率，因为已知1×1的卷积可以压缩数据[32]。上面的插图显示了CB1和CB2。因此，CB3着重显示如下。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image013.png)</p>
<p>​    其中，OCB3表示如图1所示的残差图像(视为噪声映射)。RB使用(6)来构造预测的干净图像。</p>
<p><strong>E．损失函数：</strong></p>
<p>​    我们使用下面的均方误差(MSE)[37]作为目标函数(也称为损失函数)来测量预测残差图像R(Yj)和对应的地面真实图像Yj−Xj之间的差异，其中Xj表示第j个清洁图像：</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image014.png)</p>
<p>​    其中θ表示DudeNet中训练的模型的参数。{(yj，xj)}nj=1表示N个噪声-清洁图像对。损失函数用于通过ADAM优化器[38]恢复潜在清洁图像。</p>
<h3 id="4-实验："><a href="#4-实验：" class="headerlink" title="4 实验："></a>4 实验：</h3><p><strong>A.  训练数据集：</strong></p>
<p>​    我们的训练数据分为两部分：合成图像和真实噪声图像。大小为180×180的合成噪声图像包括灰度图像和彩色图像。为了创建该训练集，我们为合成噪声数据选择了相同的400幅图像[6]。我们使用以下两种方法[39]来增加合成噪声图像的训练数据。(1)采用降尺度因子为0.7、0.8、0.9和1的双三次插值对训练数据集进行扩展。(2)采用以下八种操作来增加训练样本的多样性：无操作(即，原始图像)、90◦逆时针旋转、180◦逆时针旋转、2 70◦逆时针旋转、水平翻转、90◦逆时针旋转然后水平翻转、180◦逆时针旋转然后水平翻转、270◦逆时针旋转然后水平翻转。为了使训练后的模型更稳健，每次操作只能应用于一幅图像，并且每幅图像在一个时期内使用四次。</p>
<p>​    对于真实的噪声图像，我们使用大小为512×512的100个JPEG压缩图像[40]作为训练数据，这些图像是使用五种不同的数字设备收集的：佳能80D、尼康D800、佳能600D、索尼A7 II和佳能5D Mark II，它们带有不同参数的传感器(即800、1,600、3,200、6,400、12,800和25,600)。由于这些真实的噪声图像被压缩，对图像去噪提出了更大的挑战。</p>
<p><strong>B．测试集：</strong></p>
<p>​    所提出的DudeNet在五个公共基准数据集上进行了测试：BSD68[41]、Set12[7]、CBSD68[41]、Kodak24[42]和CC[43]。在这些数据集中，BSD68和Set12分别包含68个和12个不同场景的灰度图像。两个数据集中每个图像的大小分别为321×481和256×256。CBSD68和Kodak24分别包含68色和24色自然图像。CBSD68和Kodak24的图像大小分别为321×481和500×500。CC包含15个损坏的512×512真实世界，部分如图2所示，由3个数字设备捕获：佳能5D Mark III、尼康D600和尼康D800，具有三个ISO值(例如1,600、3,200和6,400)。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image015.png)</p>
<p><strong>C．实施细节：</strong></p>
<p>​    DudeNet的深度为18。为了加快训练速度，按照文献[44]的建议，将训练样本裁剪成大小为41×41的块来训练去噪模型。在训练阶段，初始参数设置如下：学习率为10−3，ε=10−8，批次大小为。12 8，β1=0.9，β2=0.999[45]。培训的数量：对于真实和合成噪声图像的去噪模型，Epochs为70，其中学习率设置为10−3到10−5。</p>
<p><strong>D.网络分析：</strong></p>
<p>​    1)感受野的设计：与整个图像相比，将图像分成多个块可以降低计算成本[44]。具体地说，补丁的大小通常略大于所设计网络的接收场大小。在DudeNet中，第一和第二网络的感受野大小分别为41×41和32×32，遵循[33]。需要注意的是，补丁的大小应该大于DudeNet的接受场大小，否则，补丁的大小不能满足网络填充的要求，这将降低去噪性能。考虑到计算量和去噪性能之间的权衡，我们将两个子网的平均接收场大小取为FEB：(41+32)/2=36.5≈37。因此，DudeNet的总体感受野大小为39×39，斑块大小选择为41×41。</p>
<p>​    <strong>2)FEB的设计、分析和有效性：</strong>为了提取准确的特征，我们采用了特征融合的方法来增强DudeNet的表示能力。也就是说，FEB包括第一和第二网络。对于第一种网络，所提出的稀疏机制是一个重要的组成部分，具有以下优点：</p>
<p>​    首先，它可以更好地恢复潜像的细节。其次，它可能导致浅层次的结构，这有利于解决长期依赖问题。第三，浅DudeNet具有较低的计算复杂度。</p>
<p>具体实现见第三节C部分。具体而言，该机制用具有较大膨胀因子的膨胀卷积来模拟大能量点，而用具有小膨胀因子的卷积来表示小能量点以实现稀疏性。然而，选择大的能源点是至关重要的。我们分别从稀疏性特征和网络设计两个方面解释了原因。</p>
<p>​    对于稀疏性，我们知道大的能量点是不规则分布的[47]。在此基础上，提出了寻找大能源点的具体要求。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image016.png)</p>
<p>​    大能量点在CNN中不是连续的、等距的，这有利于提高去噪性能。如果CNN中的大能量点是连续的，这将导致信息丢失。具体地说，CNN的记忆能力是有限的[48]。CNN的后一层由于不能完全理解前一层的信息，需要学习更大范围的新内容。证明了“连续高能点CB2、CB3网络”的性能比表I所示的“具有稀疏机制的第一网络CB2和CB3(FS)”的性能要差。具体地说，“连续高能点网络CB2、CB3”是CB2、CB3和第一个具有2-5层高能点(膨胀卷积)的网络的组合。此外，还注意到局部地区的网络差异越大，其性能越好[29]。因此，我们在CNN中不会选择等距的大点。这一点通过表I中的“FEBnet1的层2、层5、层8和层11的膨胀因子为2的DudeNet”和“DudeNet”进行了验证。</p>
<p>​    <strong>3）大能量点不多，能保证去噪效率：</strong>举个例子，Elep在处理噪声图像时比FS消耗更多的运行时间，如表II所示。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image017.png)</p>
<p>​    对于网络结构来说，大能量点是连续的、等距离的、多个的，这会导致效率低、去噪性能差。举个例子，我们假设第一个网络中的每一层都使用膨胀卷积。这需要在第一个网络的每一层进行填充操作，效率较低，如表II所示的“Elep”和“FS”。此外，当感受野的大小大于输入图像的块大小时，特征映射需要零填充，这会降低去噪性能。从表I中比较ELEP和FS的性能可以看出这一点，因此，在图像去噪中放弃了这一思想。此外，稀疏机制在效率和性能上具有竞争力。具体地说，FS的感受场大小为43×43，与核大小为3×3的21层相比，其去噪效果较好，但只有18层，降低了网络深度，提高了去噪效率。</p>
<p>在去噪性能方面，我们通过对表I中的“DudeNet”和“RB、EB、CB和FEB的组合(没有稀疏机制)”和“没有CB2和EB2的DudeNet”的性能进行比较，证明了稀疏机制的有效性。综上所述，FEB的FEBnet1中提出的稀疏机制是有效的。此外，FEBnet2对FEBnet1进行了合并以提高去噪性能，这将在EB中详细说明。</p>
<p>​    <strong>4）EB的设计、分析和有效性：</strong>值得注意的是，不同的网络可以从多个角度提供互补的信息[48]。而且CNN的地方架构差异更大，效果更好[29]。基于此，我们提出了一种增强学习能力的EB。具体地说，EB包括EB1和EB2两个部分。EB1集合了两个子网络，在深度相同的情况下提高了网络的表达能力。可以看出，“RB、EB1、CB和FEB无稀疏机制和BN的组合”比“FWS”和“第二个有CB2和CB3的网络”获得了更高的峰值信噪比(PSNR)。“有CB2的DudeNet和没有EB2的DudeNet”优于“FS”和“有CB2的第二个网络和CB3”。证明了FEB和EB1相结合对图像去噪是非常有效的。具体地说，两个子网络只使用一种稀疏机制来扩大FEB的差异，这在表I中是有效的，例如“具有两个稀疏机制的DudeNet”和“DudeNet”。证明了具有稀疏机制的双网络可以提取不同的特征，提高了去噪器的泛化能力。</p>
<p>​    EB2融合了获得的局部特征和原始图像信息，也可以为第一阶段和以后的网络提供补充信息。通过比较“无稀疏机制的Rb、EB1、Cb和FEB的组合”和“无稀疏机制的Rb、Eb、Cb和FEB的组合”、“DudeNet”和“DudeNet有Cb2和无EB2的DudeNet”来验证这一点。同时，BN并入FEB和EB对DudeNet有积极的影响，这反映在表I中。其原因有以下两点。首先，第一个网络中的膨胀卷积会导致所获得的特征分布不同。其次，从两个不同的网络中获取的特征不同，导致融合后的特征分布不同。这些都对图像去噪有很好的效果。因此，我们选择BN进入第一个网络，并在FEB份选择EB1来分别解决这些问题。此外，值得注意的是，EB1和EB2融合了局部特征和全局特征来增强表达能力，非常适合于未知的受污染图像，如真实世界中的噪声图像和盲去噪。</p>
<p>​    <strong>5)CB的设计、分析和有效性：</strong>为了提高效率，CB通过1×1卷积的方式对冗余特征信息进行打折。由于CB1被嵌入到FEB的第二个网络中，CB3可以将噪声特征转换为噪声映射(也称为噪声图像)。因此，我们只证明了CB2算法对图像去噪的有效性。也就是说，“有CB2的DudeNet和没有EB2的DudeNet”获得了比表I所示的“没有CB2和EB2的DudeNet”更高的PSRN。此外，如表I-III所示，有CB的DudeNet(也称为DudeNet)在性能、运行时间和计算成本方面与“每层内核大小为3×3的DudeNet”具有很强的竞争力。具体地说，为了使去噪结果更具说服力，DudeNet深度参考了DnCNN。然而，由于EB2和CB3的存在，DudeNet的深度在DnCNN之上有一层。另外，我们的网络比DnCNN更广。考虑到这些因素，我们选择18层的“两个DnCNN”作为比较方法，从峰值信噪比、运行时间和复杂度三个方面对去噪性能进行测试，其中“两个DnCNN”是由两个相同的DnCNN串联而成的。</p>
<p>​    在去噪效果上，‘DudeNet’优于表I所示的‘DnCNN’和‘Two DnCNN’。从运行时可以看出，对于有噪声的图像，‘DudeNet’接近于‘Two DnCNN’(即256×256、512×512和1024×1024)。从复杂度来看，‘DudeNet’比‘Two DnCNN’具有更少的参数和Gflops。就去噪网络的复杂度而言，“DudeNet”优于“RED30”和“每层核大小为3×3的DudeNet”。这表明该器件结构浅，滤波器尺寸小，具有较小的计算量和存储量。因此，我们的DudeNet对图像去噪是有效和高效的。</p>
<p><strong>E.  与最先进的去噪方法的比较：</strong></p>
<p>​    本文对灰度和彩色合成噪声图像、盲去噪图像和真实噪声图像四个应用进行了对比实验，并对每幅图像的运行时间进行了比较。对于这些实验，我们选择了最先进的方法，包括BM3D[5]，WNNM[4]，期望补丁对数似然(EPLL)[44]，多层感知器(MLP)[52]，CSF[8]，TNRD[9]，DnCNN[10]，DnCNN用于盲去噪(DnCNN-B)[10]，IRCNN[16]，FFDNet[15]，目标图像去噪(TID)[53。具体地说，我们使用PSNR[55，56]和运行时间作为比较去噪方法的性能指标：PSNR=10×log10((Max)2)，其中Max和MSE MSE分别是给定的干净图像和预测的干净图像之间的最大像素值和均方误差。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image018.png)</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image019.png)</p>
<p>​    灰度和彩色合成噪声图像：表IV列出了基准数据集BSD68上的灰度合成噪声图像的平均PSNR。可以看出，DudeNet的性能优于几种最先进的去噪器，即DnCNN和FFDNet。此外，带盲去噪的DudeNet(DudeNet-B)也获得了较好的性能。例如，当σ=50时，DudeNet-B比DNCNN有0.02dB的改善。图3显示了来自BSD68上的BM3D、IRCNN、FFDNet、DudeNet和DudeNet-B的可视图像。表V显示了DudeNet对每一类灰度合成噪声图像的良好去噪性能，其中对于不同的噪声级别(即15、25、50)其去噪效果最佳。图4显示了最终图像。可以看出，DudeNet产生的图像比IRCNN清晰得多。从表VI看，在不同的噪声水平(即15、25、35、50、75、[0，55])下，DudeNet和DudeNet-B与CBSD68和Kodak24的其他常用彩色合成噪声图像方法相比具有很强的竞争力。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image020.png)</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image021.png)</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image022.png)</p>
<p><strong>2)盲去噪：</strong>DudeNet–盲去噪模型。B从0训练到55 3)真实噪声图像：表VII显示了真实噪声图像的去噪性能。</p>
<p>​    DudeNet取得了很好的效果，比DnCNN提高了1.86dB。综上所述，我们的去噪模型适用于复杂的噪声任务，如彩色合成噪声图像、盲降噪和真实噪声图像。如表IV-VI所示，我们可以看到DudeNet-B在灰度和彩色图像去噪方面与FFDNet和IRCNN相比具有很强的竞争力。这证明了我们的模型对盲去噪具有很好的鲁棒性。</p>
<p>![img](Users/tianjirong/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image023.png)</p>
<p>​    表八显示了9种方法在每个不同大小的图像上的运行时间，其中DudeNet比最先进的去噪器(即RED30和MemMet)更具竞争力。表IV-VIII说明了不同方法的去噪性能(即PSNR和运行时间)，其中红线和蓝线分别表示图像去噪的最佳和次佳结果。根据前面第四节D节的分析和第四节E节的实验验证，我们可以将本文的优点提炼如下：</p>
<p>首先，具有稀疏机制的双网络可以提取不同的特征，以增强去噪器处理复杂任务(如真实噪声图像和盲噪声)的广义能力。</p>
<p>其次，将全局特征和局部特征相结合，可以获得显著的特征来恢复细微的细节，从而可以合并双网络来解决复杂的任务。</p>
<p>最后，采用较小的滤波器尺寸来降低去噪器的复杂度。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    本文提出了一种新的DudeNet图像去噪方法。DudeNet使用双重网络来提取不同的特征，以增强学习特征的表示能力以进行去噪。DudeNet的稀疏机制可以很好地在去噪性能和处理速度之间进行权衡，通过提取全局和局部特征来融合它们，获得显著的特征，从而恢复复杂噪声图像的精细细节。我们还提出使用压缩块来减少冗余信息，从而降低计算成本和内存消耗。大量实验表明，DudeNet具有较高的视觉质量和计算效率。在未来，我们打算扩展DudeNet来处理多个低级视觉任务，包括图像超分辨率和去模糊。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/09/%E5%9F%BA%E4%BA%8E%E6%B5%8B%E9%87%8F%E6%9D%A1%E4%BB%B6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%84%9F%E7%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田济荣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GeekOUC">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/09/%E5%9F%BA%E4%BA%8E%E6%B5%8B%E9%87%8F%E6%9D%A1%E4%BB%B6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%84%9F%E7%9F%A5/" itemprop="url">基于测量条件生成模型的压缩感知</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-09T19:47:01+08:00">
                2020-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于测量条件生成模型的压缩感知"><a href="#基于测量条件生成模型的压缩感知" class="headerlink" title="基于测量条件生成模型的压缩感知"></a>基于测量条件生成模型的压缩感知</h1><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    压缩感知(CS)中经常采用预训练生成器，因为它能够在NNS先验的情况下有效地估计信号。<strong>为了进一步提炼基于神经网络的先验，我们提出了一个框架，允许生成器学习特定于测量的先验分布，从而对测量产生更准确的预测。</strong><br>我们的框架有一个简单的形式，<strong>它只利用来自给定测量的额外信息进行先前学习</strong>，所以它可以很容易地应用于现有的方法。尽管该框架结构简单，但我们通过大量的实验证明，我们的框架表现出了一致的优越性能，并且在某些应用中可以将重建误差降低到一个数量级。我们还从理论上解释了实验的成功，表明我们的框架可以略微放宽严格的信号存在条件，这是保证信号恢复成功所必需的。</p>
<h2 id="1-引言："><a href="#1-引言：" class="headerlink" title="1.引言："></a>1.引言：</h2><p>​    几十年来，压缩传感(CS)一直是一种流行的方法，用于在设备数量大于测量大小时恢复信号，例如在通信中[1，2，3]，或者在医学成像[4，5，6]和光学成像[7]中测量非常昂贵。CS的目标是在给定欠采样测量向量y∈Rm的情况下，在以下线性关系下估计信号x∈Rd：</p>
<p><img src="https://i.loli.net/2020/07/09/2KyOmNbBEtaToYn.png" alt="image-20200709195307574"></p>
<p>​    其中A∈Rm×d是给定的感测矩阵，使得m&lt;d，并且ω是未知噪声。由于(1)是欠定线性系统，它需要对信号做一些基本假设以保证解的唯一性。关于CS的经典文献假设x在某些已知基上是稀疏的，并通过L1-最小化来求解(1)。</p>
<p>​    由于神经网络在有监督学习(包括回归和分类任务)和无监督学习(如聚类和密度估计任务)方面都取得了巨大的成功，因此近年来许多研究者致力于利用神经网络作为CS的结构假设[8，9，10，11，12，13，14，15，16，17，18，19，20，21，22，23，24，6]。特别地，在[22]中证明了使用预训练生成器(CSPG)的CS能够通过利用特定于领域的先验而不是通用稀疏先验来重构信号。尽管使用LASSO[25]的方法仅从由某一算子(例如，小波变换)变换的数据中捕获信号稀疏性，但现实世界的数据具有除稀疏性之外的多种特征。结果，训练生成模型使其生成器能够学习特定于领域的分布，这允许信号恢复，即使在稀疏先验的情况下，与理论下界相比，测量次数更少。</p>
<p>​    遗憾的是，CSPG的前人工作[22，18，26，27，10，8，14]只涉及训练生成器来推断信号本身的先验概率分布。由于每个训练信号的测量向量在训练生成器时都是可用的，<strong>因此我们可以通过使生成器依赖于测量并学习在测量条件下的信号分布来进一步优化生成器</strong>。在本文中，我们集中讨论如何帮助生成器学习这种测量条件分布。</p>
<p>我们的贡献有三个方面：</p>
<ul>
<li>我们提出了一个框架，使生成器能够学习特定于测量的先验分布p(x|y)。据我们所知，<strong>我们的框架是首次尝试将y插入到CS的生成模型中。</strong></li>
<li>我们为学习测量条件先验提供了理论支持，我们的框架减轻了严格的信号存在假设，从而使信号重构更加成功</li>
<li>我们的经验表明，在各种各样的先前工作的基础上，我们取得了持续的、相当大的改进。在以往生成性模型难以重建(即MRI图像重建)的真实数据上，我们进一步证明了该方法的实用性。</li>
</ul>
<h2 id="2-相关工作："><a href="#2-相关工作：" class="headerlink" title="2 相关工作："></a>2 相关工作：</h2><p>​    我们介绍了深度神经网络在CS中的几个研究方向，根据是否使用生成器，这些研究可以很大程度上分为两类：</p>
<p><strong>CS通过NNS，无需生成器：</strong></p>
<p>​    这组研究主要涉及为某些特殊目的设计神经网络体系结构。首先，文献[28]提出迭代收缩阈值算法(ISTA)的更新步骤可以表示为神经网络的每一层，并提出了一种深层结构作为ISTA的学习变体(LISTA)。由于LISTA优化了最初设置为ISTA的网络，LISTA利用其体系结构直接提高了ISTA的性能。在这种展开过程的激励下，通过展开最先进的CS算法(例如，近似消息传递、稀疏贝叶斯学习和乘子交替方向方法等)并将它们映射到特定的网络结构，已经进行了广泛的研究[29、30、31、32、33、24、23、6、19]。除了基于展开的研究之外，[11]还提出了一种卷积自动编码器的变体，以加速信号恢复并诱导数据驱动的降维。[9]提出了如何通过设计一种受投影次梯度法启发的自动编码器来学习传感矩阵。[20]研究了正则化泛函被构造为神经网络的情况。</p>
<p><strong>CS通过带生成器的NNS：</strong><br>    根据是否训练生成器，第二组进一步分为使用预训练生成器的CS(CSPG)和使用未训练的生成器的CS(CSUG)。CSPG指示通过对数据进行训练的生成器来恢复信号的算法。[22]首先利用预先训练的生成器来重构信号，提供恢复保证。此后已经进行了许多研究[18、26、14、27、8、10]以提高CSPG的绩效。与CSPG相比，诸如[17，34]之类的CSUG表示基于深度图像先验[35]的方法，从而可以仅使用一个测量向量yte来训练未训练生成器的权重。虽然CSUG即使在没有训练数据的情况下也能够恢复信号，但是CSPG的使用比CSUG更广泛，因为训练数据通常可以在实践中获得，并且CSPG通常在各个方面优于CSUG(例如，CSUG[36，34]的性能类似于基于小波的套索方法，而CSPG[22，18]的性能优于它)。</p>
<p>​    在这项工作中，我们提出了一个新的框架，该框架易于应用于CSPG，同时通过对条件生成模型的建模，显著而统一地改进了现有的CSPG方法。虽然在构建条件生成模型方面有几种选择，但我们的框架特别基于生成对抗网络(GAN)[37]，因为它在CSPG中很受欢迎。因此，我们的框架也可以理解为条件GaN(CGAN)的特例[38]，以及最近将cGAN应用于各个领域的研究[39，40，40，40，41，41，42，43，44，45，46，42，42，47，48]。然而，所有这些工作都只是针对生成任务，而不是针对恢复，特别是针对CS。</p>
<h2 id="3-CS的度量条件生成模型框架："><a href="#3-CS的度量条件生成模型框架：" class="headerlink" title="3 CS的度量条件生成模型框架："></a>3 CS的度量条件生成模型框架：</h2><p>​    在这一部分中，我们概述了CSPG的基本背景，并提出了一个简单而有效的方案来应对这一限制。</p>
<p><strong>记法:</strong>我们使用Gθ(Z)来表示具有参数θ和潜在变量z的生成器。类似地，我们使用Dφ(X)来表示具有参数φ和输入x的鉴别    器。(xtr，ytr)(或者(xte，yte))表示由(1)给出的一对训练(或测试)信号xtr(或xte，yte)和相应的测量向量ytr(或yte)。我们用p(x，y)、p(X)和p(x|y)分别表示(x，y)的联合分布、x的边缘分布和x给定y的条件分布。</p>
<p><img src="https://i.loli.net/2020/07/09/PEgQ5iIxFUvXaoJ.png" alt="image-20200709201402005"></p>
<p><strong>3.1 初步：使用预先训练的生成器进行压缩传感:</strong></p>
<p>​    使用预训练生成器(CSPG)的CS中的算法通常可以分为以下两个阶段，分别是训练(2)和测试(22)。训练阶段旨在找出给定一组训练信号{xtr}的发生器Gθ∗，φ∗和鉴别器Dθ的最佳参数(φ)：</p>
<p><img src="https://i.loli.net/2020/07/09/wc6uYqZ9TojMrAW.png" alt="image-20200709195228133"></p>
<p>​    其中，x̄表示训练信号xTR或由Gθ(Z)生成的伪信号，LTR(M)表示与模型M有关的训练的损失函数，并且FOPT[·]由操作员定义以相对于T优化其输入。通常，M={Gθ(X)，Dφ(x̄)}和T={θ，φ}，但T可以随M而变化。</p>
<p>​    在测试阶段，通过以下两个阶段的过程将目标xte估计为xˆ：我们首先找出给定训练的∗和测量yte的最优潜在变量zθ∗：</p>
<p><img src="https://i.loli.net/2020/07/09/AthMPCq1rvpK6TH.png" alt="image-20200709195401397"></p>
<p>​    其中，lte􏰁Gθ∗(Z)，yte􏰂表示用于推断的目标函数。然后，给定估计的z∗和训练的θ∗，我们将目标xte恢复为xˆ=Gθ∗(z∗)。</p>
<p><strong>3.2 测量 ： 有条件的预训练发电机：</strong></p>
<p>​    与现有的在DCGAN[50]等原始GAN框架下学习感兴趣的边际概率p(X)的CSPG方法不同，我们的框架提供了一种通过利用条件GAN[38]框架的概念来学习测量条件分布p(x|y)的方法。本质上，我们不仅通过“噪声”产生信号分布，而且利用特定的“测量信息”来产生信号分布，从而利用测量向量的附加信息来进一步提炼先验。在CS中关于满足p(x，y)&gt;0的所有(x，y)都存在从y到x的逆映射的经典假设下，如果生成器准确地推导出p(x|y)，则它可以成功地从yte恢复XTE。当然，在实践中，几乎不存在这样理想的逆映射。然而，如图1(A)中经验所示，条件生成器仍然可以为目标信号提供更精细的先验，从而增加了在后续信号重构阶段(如(22))中的成功机会。</p>
<p>​    <strong>这种称为“插入测量”(IM)的方法可以很容易地应用于任何使用预训练生成器(CSPG)的CS方法，如图2所示</strong>。与判别性模型(即，用于CS的学习NNS，其在没有任何生成器的情况下将测量直接映射到目标信号)不同，CS的生成模型具有潜在变量矢量z，该潜在变量矢量z可以在测试阶段VIA(22)中进行优化，以找到更接近真实信号的估计。在这个过程中，可以同时使用生成模型中的各种样本来帮助有效地实现这一目标。如图1(B)所示，我们的方法继承了生成模型的优点，同时采取了类似的区分方法的精神，从而改进了CS的生成模型。</p>
<p><img src="https://i.loli.net/2020/07/09/xLzb38YQuywq9Hn.png" alt="image-20200709195608370"></p>
<p><img src="https://i.loli.net/2020/07/09/t5IJvcXCbrwgHOA.png" alt="image-20200709195642744"></p>
<h2 id="4-在我们的框架下看现有的CSPG模型："><a href="#4-在我们的框架下看现有的CSPG模型：" class="headerlink" title="4 在我们的框架下看现有的CSPG模型："></a>4 在我们的框架下看现有的CSPG模型：</h2><p>​    我们现在提供的例子展示了我们的框架，将IM用于各种CSPG模型，例如使用生成模型的压缩传感(CSGM)[22]和投影梯度下降GaN(PGDGAN)[26]。IM在深度压缩传感(DCS)[10]和SparseGen[18]中的应用推迟到附录。</p>
<p><strong>使用生成模型的压缩传感(CSGM)：</strong></p>
<p>​    基于生成模型的压缩传感(CSGM)[22]是第一个在(2)和(22)中提出基于GaN的CSPG框架的工作。虽然它允许任何GaN模型，但是如果如[22]所示使用包括DCGAN[50]的标准GaN训练目标，则通过解决以下最小-最大问题来训练生成器Gθ和鉴别器Dφ：</p>
<p><img src="https://i.loli.net/2020/07/09/RernQUZsuKI3NcA.png" alt="image-20200709200120454"></p>
<p>​    在其框架下开始了另一个合理的GAN实例。在这种情况下，CSGM的培训阶段可以给出如下形式：</p>
<p><img src="https://i.loli.net/2020/07/09/1yqVJCBitD5RlE4.png" alt="image-20200709200152340"></p>
<p>​    其中，R_φ(x_̄)=∥<em>x</em>̄−<em>D</em>φ(x_̄)∥_p)表示由D_φ根据p=1或2范数确定的重建损失，并且参数ζ控制自动编码真实图像和区分真实图像与虚假图像之间的平衡。当(6)中的Dφ输出指示其输入是否是真实图像的标量值(概率)时，(7)中的Dφ基于其输入重建图像。</p>
<p>​    测试阶段中的CSGM通过最小化关于预训练生成器Gˆ的输入噪声z的以下损失来计算目标信号xte的估计xθ∗=G∗(zθ∗)：</p>
<p><img src="https://i.loli.net/2020/07/09/Fq13v2lXWmAUgLM.png" alt="image-20200709200427206"></p>
<p><strong>CSGM-IM：</strong></p>
<p>​    我们现在展示在我们的框架下如何将所提出的方案应用于CSGM。我们将此应用程序命名为CSGM-IM。CSGM-IM的训练阶段根据以下优化(9)(针对DCGAN)和(10)(针对BEGIN)学习(θ，φ)，它们分别由(6)和(7)修订而来：</p>
<p>​    ![image-20200709200537879](/Users/tianjirong/Library/Application Support/typora-user-images/image-20200709200537879.png)</p>
<p>​    在测试阶段，CSGM-IM通过将测试测量一致地馈送到学习生成器来估计目标信号xte为xˆ=Gθ∗(z∗，yte)：</p>
<p><img src="https://i.loli.net/2020/07/09/Gd6UnAyXLtORMDs.png" alt="image-20200709200642746"></p>
<p>​    我们在图2中说明了CSGM-IM与CSGM的不同之处，并将他们的算法加到附录中。</p>
<p><strong>4.2 投影梯度下降GaN(PGDGAN)：</strong></p>
<p>​    投影梯度下降GaN(PGDGAN)[26]是将投影梯度方法应用于CSPG框架的代表性工作。与CSGM类似，PGDGAN的训练阶段可以是任何优化生成器Gθ的学习方案，如(6)或(7)。然而，在测试阶段，PGDGAN通过联合减小欧几里得测量误差[26]和使信号估计属于预训练生成器的范围来恢复信号。具体地说，测试阶段的PGDGAN通过迭代求解以下关于预训练生成器Gˆ的输入噪声z的递归公式来计算目标信号xTE的估计xθ∗=xT：</p>
<p><img src="https://i.loli.net/2020/07/09/AsHNEzh58MUoYcm.png" alt="image-20200709200741272"></p>
<p>​    对于t=0，···，T_−_1，其中PG_θ∗(H)=G_θ∗(argminz_∥<em>h</em>−<em>G</em>θ∗(Z)∥)表示将输入h映射到预先训练生成器G_θ∗，x0=0或A_⊤_yte的范围内最接近h的点的投影算子，通常，α是学习率，T是迭代的总次数。注意，(12)中的第二项的内部和外部计算分别将估计更新为减小欧几里得测量误差的方向，并将该更新的估计投影到Gθ∗的范围内。因此，PGDGAN可以被认为是用基于网络的正则化算法来解决最小二乘问题，而不是用CS中通常使用的稀疏提升正则化算法来解决最小二乘问题。</p>
<p><strong>PGDGAN-IM：</strong></p>
<p>​    我们现在描述IM如何在我们的框架下应用于PGDGAN。我们将此应用程序命名为PGDGAN-IM。由于PGDGAN具有与CSGM相同的训练阶段，PGDGAN-IM也具有与CSGM-IM相同的训练阶段((9)或(10))。在测试阶段，PGDGAN-IM通过将测试测量一致地馈送到训练的生成器来估计目标信号xte为xˆ=xt：</p>
<p><img src="https://i.loli.net/2020/07/09/VuHw49lUTOpt6AC.png" alt="image-20200709200837186"></p>
<p>​    我们在附录中给出了PGDGAN和PGDGAN-IM的算法。</p>
<h2 id="5-实验："><a href="#5-实验：" class="headerlink" title="5 实验："></a>5 实验：</h2><p>​    为了评估算法的有效性，我们重点在CelebA[52]数据集上进行了实验，这是一项常见但比MNIST[53]或Omniglot[54]数据集更困难的任务。图像在中心被裁剪成大小为64×64×3(d=12288)并归一化到范围[−1，1]。为了进行推断，我们利用测试集中的64个随机图像，以5次试验的95%置信区间计算重建误差∥xTe−xˆ∥2。感测矩阵A的每个条目从正态分布N(0，1/m)采样。除非另有说明，否则我们遵循与[22]相同的实验设置。当将y添加到生成模型中时，在DCGAN和BEGIN中，y都连接到Gθ中的z。在BEGIN中，Y还连接到Dφ中的嵌入层。由于在DCGAN的Dφ中没有嵌入层，我们仿真了[55]中提出的体系结构。关于实验设置和不同m上的实验结果的进一步信息在附录中给出。</p>
<p><strong>CSGM-IM</strong>：</p>
<p><img src="https://i.loli.net/2020/07/09/gq9y3f21WzUSZhE.png" alt="image-20200709201502679"></p>
<p>​    如表2所示，IM显著改善了所有m个的CSGM。平均而言，IM将重建误差降低了30%以上。虽然IM极大地提高了CSGM在小m情况下的性能，但它仍然表现出与CSGM一样的性能饱和。当攻击开始时，CSGM-IM表现出更令人信服的性能，并克服了这样的限制。与表2和表2中的最后一列相比，对于每m个m，使用BEGIN的CSGM-IM的每像素重建误差小于使用DCGAN。更引人注目的是，对于表2中的m≥，使用BEGIN的CSGM-IM的每像素重建误差几乎小于使用START的CSGM的每像素重建误差一个数量级。结果，不仅使用START的CSGM-IM在m=1000时恢复了与原始图像相似的图像(m/d≈为8.14%)，而且在m=5000(m/d≈为40.69%)时重建的图像与原始图像几乎相同，如图3所示。</p>
<p><img src="https://i.loli.net/2020/07/09/9di4UoTPfm2M5jQ.png" alt="image-20200709201522512"></p>
<p><strong>PGDGAN-IM：</strong></p>
<p>​    为进行公平比较，我们遵循与[26]相同的超参数。在表2中，PGDGAN-IM比PGDGAN的重建误差平均降低30%以上。</p>
<p><strong>DCS-IM</strong></p>
<p>​    为了验证我们方法的有效性，在没有D-φ的情况下，我们将IM应用到DCS中。表2显示，IM将DCS的重构误差降低了70%以上。当m≤为100时，dcs-IM的性能尤其优于所有其他方法，这意味着IM使dcs在小m中的实力更加突出。此外，IM将mCSGM-IM的每个像素的重建误差降低了mCSGM 1000的一个数量级，从而实现了像使用如图3所示的BEGIN的≥-IM那样的成功信号恢复。</p>
<p>​    SparseGen-IM我们只考虑小波基，因为[18]推荐的是小波基，而不是离散余弦变换。表2表明，SparseGen-IM优于SparseGen，重建误差平均减少38%左右。</p>
<h2 id="6-在磁共振成像中的应用："><a href="#6-在磁共振成像中的应用：" class="headerlink" title="6 在磁共振成像中的应用："></a>6 在磁共振成像中的应用：</h2><p>​    为了验证IM在真实数据上的实用性，我们在FAST MRI[56]数据集上进行了实验。特别地，我们利用了膝部数据集。由于测试切片质量不高，我们将验证切片作为测试集。与[56]类似，图像在中心被裁剪到大小256×256，并且被下采样到大小128×128(d=16384)。任何数据扩充都不是为了表明IM可以鼓励以前的方法即使在少量数据上也能很好地执行。为了进行测试，我们在验证切片中使用了64个随机图像。更多信息见附录。与第6节相同，感测矩阵A的每个条目也从正态分布N(0，1/m)中采样，并且重建误差被用作评估度量。与(1)不同，在创建测量矢量yte时不添加噪声。在这个实验中，我们只使用BEGIN架构，因为它在我们的实验中工作得最好。</p>
<p>​    与第6节类似，CSGM-IM的性能比CSGM好得多。如表3所示，IM将m≥2500CSGM的重建误差降低了近一个数量级。不仅如此，如图4所示，CSGM-IM可以恢复与原始图像高度相似的图像，而CSGM根本不能。</p>
<p><img src="https://i.loli.net/2020/07/09/P7HfY4NJupqyiMb.png" alt="image-20200709201541597"></p>
<h2 id="7-结论："><a href="#7-结论：" class="headerlink" title="7 结论："></a>7 结论：</h2><p>​    我们提出了一种简单而有效的方法，即插入测量值，使生成器能够学习p(x|y)而不是p(X)。即使在IM框架中，生成性模型的特点仍然存在，这使得我们可以通过潜在优化找到更接近真实信号的估计。通过利用判别模型和生成模型的优点，IM可以产生比现有方法小得多的重建误差，最高可达一个数量级。因此，我们期望IM能够用于各种CS应用程序以及图像恢复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">田济荣</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jirong0214" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:geekouc@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://i.loli.net/2020/07/09/PqjnfpmXblhDYOJ.jpg" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-wechat"></i>Wechat</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">田济荣</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
